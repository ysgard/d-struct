# D Language grammar for Atom
#
# Author: Jan Van Uytven

# For colors, as an example, Monokai defines the following.  It is probably
# likely that this are 'baseline' rules, as Monokai is one of the most
# popular styles
# .comment -> warm grey
# .string -> warm yellow
# .string source
# .string.unquoted
# .constant -> violet
# .constant.numeric -> violet
# .constant.language -> violet
# .constant.character -> violet
# .constant.other -> violet
# .declaration.section entity.name.section
# .declaration.tag
# .deco.folding
# .keyword -> coral
# .keyword.control
# .keyword.operator
# .storage -> coral
# .storage.type -> blue italic
# .entity.other.inherited-class -> lime italic underline
# .entity.name.function -> lime
# .entity.name.instance -> lt blue
# .entity.name.class -> lime underline
# .entity.name.tag -> coral
# .entity.name.type
# .entity.other.attribute-name -> lime
# .support.function -> blue
# .support.type -> italic blue
# .support.class -> italic blue
# .support.constant
# .support.variable
# .invalid -> white on coral
# .invalid.deprecated -> white on purple
# .variable.parameter -> orange italic
# .variable
# .variable.language
# .variable.other
# .meta.embedded
# .meta.preprocessor
# .meta.section entity.name.section
# .meta.tag
# .text source
# .gfm.markup.list
# .gfm.markup.quote
# .gfm.markup.heading -> bold lime
# .gfm.markup.underline -> warm yellow underline
# .gfm.markup.bold -> bold
# .gfm.markup.italic -> italic
# .gfm.markup.raw -> blue
# .gfm.markup.variable.list -> bold coral
# .gfm.markup.link -> lt grey
# .gfm.markup.link.entity -> violet

# The order of rules in 'patterns' is important - matching stops
# as soon as a match is found, starting from the top down.
{
  'fileTypes': [
    'd', 'di'
  ],
  'name': 'D',
  'scopeName': 'source.d',

  'patterns': [

    {
      'include': '#pragma'
    },
    {
      'include': '#type'
    },
    {
      'include': '#lexical',
    }

  ],

  'repository': {
    #
    # GENERAL GRAMMAR
    #
    'type': {
      'patterns': [
        { 'include': '#type-ctor' },
        { 'include': '#basic-type' },

      ]
    },
    'type-ctor': {
      'patterns': [
        'match': '(const|immutable|inout|shared)+',
        'name': 'storage.type.modifier.d'
      ]
    },
    'basic-type': {
      'patterns': [
        { 'include': '#basic-type-x' },
        { 'include': '#typeof' },
        { 'include': '#type-ctor-type' },
      ]
    },
    'basic-type-x': {
      'patterns': [
        'match': 'bool|byte|ubyte|short|ushort|int|uint|long|ulong|char|wchar|dchar|float|double|real|ifloat|idouble|ireal|cfloat|cdouble|creal|void',
        'name': 'storage.type.basic-type-x.d'
      ]
    },
    'typeof': {
      'begin': 'typeof\\s+\\(',
      'end': '\\)',
      'name': 'storage.type.typeof.d',
      'patterns': [
        {
            'match': 'return',
            'name': 'keyword.control.return.d'
        },
        { 'include': '#expression' }
      ],
    },
    'type-ctor-type': {
      'begin': '(const|immutable|inout|shared)\\s+\\(',
      'end': '\\)',
      'name': 'storage.type.ctor-type.d',
      'patterns': [
        { 'include': '#type' },
      ]
    },
    'storage-class': {
      'patterns': [
        { 'include': '#linkage-attribute' },
        { 'include': '#align-attribute' },
        {
          'match': 'deprecated|enum|static|extern|abstract|final|override|synchronized|auto|scope|const|immutable|inout|shared|__gshared|nothrow|pure|ref',
          'name': 'storage.class.d'
        },
        { 'include': '#property' },
      ]
    }
    'linkage-attribute': {
      'patterns': [
        'match': 'C|C\\+\\+|D|Windows|Pascal|System',
        'name': 'storage.modifier.linkage-attribute.d'
      ]
    },
    'align-attribute': {
      'patterns': [
        {
          'begin': 'align\\(',
          'end': '\\)',
          'name': 'storage.modifier.align-attribute.d',
          'patterns': [
            { 'include': '#integer-literal' }
          ]
        },
        {
          'match': 'align[^\\(]',
          'name': 'storage.modifier.align-attribute.d',
        }
      ]
    },
    'property': {
      'patterns': [
        {
          'match': '@(property|safe|trusted|system|disable|nogc)',
          'name': 'entity.name.tag.property.d',
        },
        {
          'match': '@([_\\w][_\\d\\w]*)',
          'name': 'entity.name.tag.user-defined-property.d',
        },
        {
          'begin': '@([_\\w][_\\d\\w]*)\\(',
          'end': '\\)',
          'name': 'entity.name.tag.user-defined-property.d',
          'patterns': [

          ]
        }
      ]
    },
    'pragma': {
      'patterns': [
        {
          'match': 'pragma\\s?\\(\\s*[_\\w][_\\d\\w]*\\s*\\)',
          'name': 'meta.preprocessor.d'
        },
        {
          'begin': 'pragma\\s?\\(\\s*[_\\w][_\\d\\w]*\\s*,',
          'end': '\\)',
          'name': 'meta.preprocessor.d'
          'patterns': [

          ]
        }
      ]
    }




    #
    # LEXICAL TOKENS
    #
    'lexical': {
      'patterns': [
        { 'include': '#comment' },
        { 'include': '#string-literal' },
        { 'include': '#character-literal' },
        { 'include': '#float-literal' },
        { 'include': '#integer-literal' },
        { 'include': '#special-tokens' },
        { 'include': '#special-token-sequence' },
        { 'include': '#identifier' },
      ]
    }
    #
    # Integer literals
    #
    'integer-literal': {
      'patterns': [
        { 'include': '#decimal-integer' },
        { 'include': '#binary-integer' },
        { 'include': '#hexadecimal-integer' }
      ]
    },
    'decimal-integer': {
      # We avoid including sub-rules at this point, as we can handle this
      # with a single regex
      'patterns': [
        'match': '(0(?=[^\\dxXbB]))|([1-9][0-9_]*)(Lu|LU|uL|UL|L|u|U)?',
        'name': 'constant.numeric.integer.decimal.d'
      ]
    },
    'binary-integer': {
      'patterns': [
        'match': '(0b|0B)[0-1_]+(Lu|LU|uL|UL|L|u|U)?',
        'name': 'constant.numeric.integer.binary.d'
      ]
    },
    'hexadecimal-integer': {
      'patterns': [
        'match': '(0x|0X)([0-9a-fA-F][0-9a-fA-F_]*)(Lu|LU|uL|UL|L|u|U)?',
        'name': 'constant.numeric.integer.hexadecimal.d'
      ]
    },
    #
    # Float literals
    #
    'float-literal': {
      'patterns': [
        { 'include': '#decimal-float' },
        { 'include': '#hexadecimal-float' }
      ]
    },
    'decimal-float': {
      'patterns': [
        'match': '((\\.[0-9])|(0\\.)|(([1-9]|(0[1-9_]))[0-9_]*\\.))[0-9_]*((e-|E-|e\\+|E\\+|e|E)[0-9][0-9_]*)?[LfF]?i?',
        'name': 'constant.numeric.float.decimal.d'
      ]
    },
    'hexadecimal-float': {
      # Is there a reason why anyone would use a hexadecimal floating point?  Mystery...
      'patterns': [
        'match': '0[xX][0-9a-fA-F_]*(\\.[0-9a-fA-F_]*)?(p-|P-|p\\+|P\\+|p|P)[0-9][0-9_]*[LfF]?i?',
        'name': 'constant.numeric.fload.hexadecimal.d'
      ]
    },

    #
    # String literals
    #
    'string-literal': {
      'patterns': [
        { 'include': '#wysiwyg-string' },
        { 'include': '#alternate-wysiwyg-string' },
        { 'include': '#hex-string' },
        { 'include': '#delimited-string' },
        { 'include': '#double-quoted-string' },
        { 'include': '#token-string' }
      ]
    },
    'wysiwyg-string': {
      'patterns': [
        'begin': 'r\\"',
        'end': '\\"[cwd]?',
        'name': 'string.wysiwyg-string.d',
        'patterns': [
          { 'include': '#wysiwyg-chars' }
        ]
      ]
    },
    'alternate-wysiwyg-string': {
      'patterns': [
        'begin': '`',
        'end': '`[cwd]?',
        'name': 'string.alternate-wysiwyg-string.d',
        'patterns': [
          { 'include': '#wysiwyg-characters' }
        ]
      ]
    },
    'double-quoted-string': {
      'patterns': [
        'begin': '"',
        'end': '"[cwd]?',
        'name': 'string.double-quoted-string.d',
        'patterns': [
          { 'include': '#double-quoted-characters' }
        ]
      ]
    },
    'hex-string': {
      'patterns': [
        'begin': 'x"',
        'end': '"[cwd]?',
        'name': 'string.hex-string.d',
        'patterns': [
          {
            'match': '[a-fA-F0-9_\s]+',
            'name': 'constant.character.hex-string.d'
          }
        ]
      ]
    },
    'delimited-string': {
      'begin': 'q"',
      'end': '"',
      'name': 'string.delimited.d',
      'patterns': [
        { 'include': '#delimited-string-bracket' },
        { 'include': '#delimited-string-parens' },
        { 'include': '#delimited-string-angle-brackets' },
        { 'include': '#delimited-string-braces' },
        { 'include': '#delimited-string-arbitrary' },
      ]
    },
    'token-string': {
      'begin': 'q\\{',
      'end': '\\}',
      'name': 'string.token.d',
      'patterns': [
        { 'include': '#tokens' }
      ]
    },
    'delimited-string-arbitrary': {
      # Tricky one, as we can't match the arbitrary delimiter between a 'begin'
      # or 'end', so we have to hack this one:
      'patterns': [
        'match': '(.)([\\w\\s\\n]*?)(\\1)'
        'captures': {
          '1': {
            'name': 'constant.character.delimiter.d'
          },
          '2': {
            'name': 'string.delimited.d'
          },
          '3': {
            'name': 'constant.character.delimiter.d'
          },
        }
      ]
    },
    'delimited-string-bracket': {
      'patterns': [
        'begin': '\\[',
        'end': '\\]',
        'name': 'constant.characters.delimited.brackets.d',
        'patterns': [
          { 'include': '#wysiwyg-characters' }
        ]
      ]
    },
    'delimited-string-parens': {
      'patterns': [
        'begin': '\\(',
        'end': '\\)',
        'name': 'constant.character.delimited.parens.d',
        'patterns': [
          { 'include': '#wysiwyg-characters' }
        ]
      ]
    },
    'delimited-string-angle-brackets': {
      'patterns': [
        'begin': '<',
        'end': '>',
        'name': 'constant.character.angle-brackets.d',
        'patterns': [
          { 'include': '#wysiwyg-characters' }
        ]
      ]
    },
    'delimited-string-braces': {
      'patterns': [
        'begin': '\\{',
        'end': '\\}',
        'name': 'constant.character.delimited.braces.d',
        'patterns': [
          { 'include': '#wysiwyg-characters' }
        ]
      ]
    },

    'wysiwyg-characters': {
      'patterns': [
        { 'include': '#character' },
        { 'include': '#end-of-line' }
      ]
    },
    'double-quoted-characters': {
      'patterns': [
        { 'include': '#character' },
        { 'include': '#end-of-line' },
        { 'include': '#escape-sequence' }
      ]
    },
    'escape-sequence': {
      'patterns': [
        {
          # named entities
          'match': '(\\\\(?:quot|amp|lt|gt|OElig|oelig|Scaron|scaron|Yuml|circ|tilde|ensp|emsp|thinsp|zwnj|zwj|lrm|rlm|ndash|mdash|lsquo|rsquo|sbquo|ldquo|rdquo|bdquo|dagger|Dagger|permil|lsaquo|rsaquo|euro|nbsp|iexcl|cent|pound|curren|yen|brvbar|sect|uml|copy|ordf|laquo|not|shy|reg|macr|deg|plusmn|sup2|sup3|acute|micro|para|middot|cedil|sup1|ordm|raquo|frac14|frac12|frac34|iquest|Agrave|Aacute|Acirc|Atilde|Auml|Aring|Aelig|Ccedil|egrave|eacute|ecirc|iuml|eth|ntilde|ograve|oacute|ocirc|otilde|ouml|divide|oslash|ugrave|uacute|ucirc|uuml|yacute|thorn|yuml|fnof|Alpha|Beta|Gamma|Delta|Epsilon|Zeta|Eta|Theta|Iota|Kappa|Lambda|Mu|Nu|Xi|Omicron|Pi|Rho|Sigma|Tau|Upsilon|Phi|Chi|Psi|Omega|alpha|beta|gamma|delta|epsilon|zeta|eta|theta|iota|kappa|lambda|mu|nu|xi|omicron|pi|rho|sigmaf|sigma|tau|upsilon|phi|chi|psi|omega|thetasym|upsih|piv|bull|hellip|prime|Prime|oline|frasl|weierp|image|real|trade|alefsym|larr|uarr|rarr|darr|harr|crarr|lArr|uArr|rArr|dArr|hArr|forall|part|exist|empty|nabla|isin|notin|ni|prod|sum|minux|lowast|radic|prop|infin|ang|and|or|cap|cup|int|there4|sim|cong|asymp|ne|equiv|le|ge|sub|sup|nsub|sube|supe|oplus|otimes|perp|sdot|lceil|rceil|lfloor|rfloor|loz|spades|clubs|hearts|diams|lang|rang))',
          'name': 'constant.character.escape-sequence.entity.d'
        },
        {
          'match': '(\\\\x[0-9a-fA-F_]{2}|\\\\u[0-9a-fA-F_]{4}|\\\\U[0-9a-fA-F_]{8}|\\\\[0-7]{1,3})',
          'name': 'constant.character.escape-sequence.number.d',
        },
        {
          'match': '(\\\\t|\\\\\'|\\\\\"|\\\\\\?|\\\\0|\\\\a|\\\\b|\\\\f|\\\\n|\\\\r|\\\\v|\\\\\\\\)',
          'name': 'constant.character.escape-sequence.d',
        }
      ]
    },
    #
    # Character literal
    #
    'character-literal': {
      'patterns': [
        'match': "\'(?:(.)|(?:(?=\\\\)(.+)))\'"
        'name': 'string.character-literal.d',
        'captures': {
          '1' : {
            'patterns': [
              { 'include': '#character' }
            ]
          },
          '2': {
            'patterns': [
              { 'include': '#escape-sequence' }
            ]
          }
        }
      ]
    },
    'character': {
      'patterns': [
        'match': '[\\w\\s]',
        'name': 'string.character.d'
      ]
    },
    'end-of-line': {
      'patterns': [
        'match': '\\n',
        'name': 'string.character.end-of-line.d'
      ]
    },
    #
    # Identifiers
    #
    'identifier': {
      'patterns': [
        {
          'match': '\\.?[_\\w][_\\d\\w]*',
          'name': 'variable.d'
        }
      ]
    },
    #
    # Comments
    #
    'comment': {
      'patterns': [
        { 'include': '#block-comment' },
        { 'include': '#line-comment' },
        { 'include': '#nesting-block-comment' }
      ]
    },
    'block-comment': {
      'patterns': [
        {
          'begin': '/\\*',
          'end': '\\*/',
          'name': 'comment.block.d'
        }
      ]
    },
    'line-comment': {
      'patterns': [
        {
          'match': '//.+$',
          'name': 'comment.line.d'
        }
      ]
    },
    'nesting-block-comment': {
      'patterns': [
        {
          'begin': '/\\+',
          'end': '\\+/',
          'name': 'comment.block.documentation.d',
          'patterns': [
            { 'include': '$self' }
          ]
        }
      ]
    },
    #
    # Lexical Tokens, keywords and special tokens
    #
    'tokens': {
      'patterns': [
        { 'include': '#string-literal' },
        { 'include': '#character-literal' },
        { 'include': '#integer-literal' },
        { 'include': '#float-literal' },
        { 'include': '#keyword' },
        {
          'match': '/|/=|\\.|\\.\\.|\\.\\.\\.|&|&=|&&|\\||\\|=|\\|\\||-|-=|--|\\+|\\+=|\\+\\+|<|<=|<<|<>|>|>=|>>=|>>|>>>|\\!|\\!=|\\!<>|\\!<>=|\\!<|\\!<=|\\!>|\\!>=|\\(|\\)|\\[|\\]|\\{|\\}|\\?|,|;|:|$|=|==|\\*|\\*=|%|%=|\\^|\\^=|\\^\\^|\\^\\^=|~|~=|@|=>|#',
          'name': 'meta.lexical.token.symbolic.d'
        },
        { 'include': '#identifier' }
      ]
    },
    'keyword': {
      'patterns': [
        'match': 'abstract|alias|align|asm|assert|auto|body|bool|break|byte|case|cast|catch|cdouble|cent|cfloat|char|class|const|continue|creal|dchar|debug|default|delegate|delete|deprecated|do|double|else|enum|export|extern|false|final|finally|float|for|foreach|foreach_reverse|function|goto|idouble|if|ifloat|immutable|import|in|inout|int|interface|invariant|ireal|is|lazy|long|macro|mixin|module|new|nothrow|null|out|override|package|pragma|private|protected|public|pure|real|ref|return|scope|shared|short|static|struct|super|switch|synchronized|template|this|throw|true|try|typedef|typeid|typeof|ubyte|ucent|uint|ulong|union|unittest|ushort|version|void|volatile|wchar|while|with|__FILE__|__MODULE__|__LINE__|__FUNCTION__|__PRETTY_FUNCTION__|__gshared|__traits|__vector|__parameters',
        'name': 'keyword.token.d'
      ]
    },
    'special-token-sequence': {
      'patterns': [
        'match': '#\\s*line\\s+.+',
        'name': 'gfm.markup.italic.special-token-sequence.d'
      ]
    },
    'special-tokens': {
      'patterns': [
        'match': '__DATE__|__EOF__|__TIME__|__TIMESTAMP__|__VENDOR__|__VERSION__',
        'name': 'gfm.markup.raw.special-tokens.d'
      ]
    }
  } # End of repository
} # End of d.cson
