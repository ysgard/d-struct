# D Language grammar for Atom
#
# Author: Jan Van Uytven

# For colors, as an example, Monokai defines the following.  It is probably
# likely that this are 'baseline' rules, as Monokai is one of the most
# popular styles
# .comment -> warm grey
# .string -> warm yellow
# .string source
# .string.unquoted
# .constant -> violet
# .constant.numeric -> violet
# .constant.language -> violet
# .constant.character -> violet
# .constant.other -> violet
# .declaration.section entity.name.section
# .declaration.tag
# .deco.folding
# .keyword -> coral
# .keyword.control
# .keyword.operator
# .storage -> coral
# .storage.type -> blue italic
# .entity.other.inherited-class -> lime italic underline
# .entity.name.function -> lime
# .entity.name.instance -> lt blue
# .entity.name.class -> lime underline
# .entity.name.tag -> coral
# .entity.name.type
# .entity.other.attribute-name -> lime
# .support.function -> blue
# .support.type -> italic blue
# .support.class -> italic blue
# .support.constant
# .support.variable
# .invalid -> white on coral
# .invalid.deprecated -> white on purple
# .variable.parameter -> orange italic
# .variable
# .variable.language
# .variable.other
# .meta.embedded
# .meta.preprocessor
# .meta.section entity.name.section
# .meta.tag
# .text source
# .gfm.markup.list
# .gfm.markup.quote
# .gfm.markup.heading -> bold lime
# .gfm.markup.underline -> warm yellow underline
# .gfm.markup.bold -> bold
# .gfm.markup.italic -> italic
# .gfm.markup.raw -> blue
# .gfm.markup.variable.list -> bold coral
# .gfm.markup.link -> lt grey
# .gfm.markup.link.entity -> violet

# The order of rules in 'patterns' is important - matching stops
# as soon as a match is found, starting from the top down.
{
  'fileTypes': [
    'd', 'di'
  ],
  'name': 'D',
  'scopeName': 'source.d',

  'patterns': [
    {
      'include': '#comment'
    },
    {
      'include': '#string-literal'
    },
    {
      'include': '#character-literal'
    },
    {
      'include': '#integer-literal'
    },
    {
      'include': '#identifier'
    }

  ],

  'repository': {
    #
    # Integer literals
    #
    'integer-literal': {
      'patterns': [
        { 'include': '#integer' },
        { 'include': '#integer-suffix' }
      ]
    },
    'integer': {
      'patterns': [
        { 'include': '#decimal-integer' },
        { 'include': '#binary-integer' },
        { 'include': '#hexadecimal-integer' }
      ]
    },
    'integer-suffix': {
      'patterns': [
        'match': '(L|u|U|Lu|LU|uL|UL)',
        'name': 'constant.numeric.integer.suffix.d'
      ]
    },
    'decimal-integer': {
      # We avoid including sub-rules at this point, as we can handle this
      # with a single regex
      'patterns': [
        'match': '(0(?=[^\\dxXbB]))|([1-9][0-9_]*)',
        'name': 'constant.numeric.integer.decimal.d'
      ]
    },
    'binary-integer': {
      'patterns': [
        'match': '(0b|0B)[0-1_]+',
        'name': 'constant.numeric.integer.binary.d'
      ]
    },
    'hexadecimal-integer': {
      'patterns': [
        'match': '(0x|0X)([0-9a-fA-F][0-9a-fA-F_]*)',
        'name': 'constant.numeric.integer.hexadecimal.d'
      ]
    },

    #
    # String literals
    #
    'string-literal': {
      'patterns': [
        { 'include': '#wysiwyg-string' },
        { 'include': '#alternate-wysiwyg-string' },
        { 'include': '#hex-string' },
        { 'include': '#delimited-string' },
        { 'include': '#double-quoted-string' },
        { 'include': '#token-string' }
      ]
    },
    'wysiwyg-string': {
      'patterns': [
        'begin': 'r\\"',
        'end': '\\"[cwd]?',
        'name': 'string.wysiwyg-string.d',
        'patterns': [
          { 'include': '#wysiwyg-chars' }
        ]
      ]
    },
    'alternate-wysiwyg-string': {
      'patterns': [
        'begin': '`',
        'end': '`[cwd]?',
        'name': 'string.alternate-wysiwyg-string.d',
        'patterns': [
          { 'include': '#wysiwyg-characters' }
        ]
      ]
    },
    'double-quoted-string': {
      'patterns': [
        'begin': '"',
        'end': '"[cwd]?',
        'name': 'string.double-quoted-string.d',
        'patterns': [
          { 'include': '#double-quoted-characters' }
        ]
      ]
    },
    'hex-string': {
      'patterns': [
        'begin': 'x"',
        'end': '"[cwd]?',
        'name': 'string.hex-string.d',
        'patterns': [
          {
            'match': '[a-fA-F0-9_\s]+',
            'name': 'constant.character.hex-string.d'
          }
        ]
      ]
    },
    'delimited-string': {
      'begin': 'q"',
      'end': '"',
      'name': 'string.delimited.d',
      'patterns': [
        { 'include': '#delimited-string-bracket' },
        { 'include': '#delimited-string-parens' },
        { 'include': '#delimited-string-angle-brackets' },
        { 'include': '#delimited-string-braces' },
        { 'include': '#delimited-string-arbitrary' },
      ]
    },
    'token-string': {
      'begin': 'q\\{',
      'end': '\\}',
      'name': 'string.token.d',
      'patterns': [
        { 'include': '#tokens' }
      ]
    },
    'delimited-string-arbitrary': {
      # Tricky one, as we can't match the arbitrary delimiter between a 'begin'
      # or 'end', so we have to hack this one:
      'patterns': [
        'match': '(.)([\\w\\s\\n]*?)(\\1)'
        'captures': {
          '1': {
            'name': 'constant.character.delimiter.d'
          },
          '2': {
            'name': 'string.delimited.d'
          },
          '3': {
            'name': 'constant.character.delimiter.d'
          },
        }
      ]
    },
    'delimited-string-bracket': {
      'patterns': [
        'begin': '\\[',
        'end': '\\]',
        'name': 'constant.characters.delimited.brackets.d',
        'patterns': [
          { 'include': '#wysiwyg-characters' }
        ]
      ]
    },
    'delimited-string-parens': {
      'patterns': [
        'begin': '\\(',
        'end': '\\)',
        'name': 'constant.character.delimited.parens.d',
        'patterns': [
          { 'include': '#wysiwyg-characters' }
        ]
      ]
    },
    'delimited-string-angle-brackets': {
      'patterns': [
        'begin': '<',
        'end': '>',
        'name': 'constant.character.angle-brackets.d',
        'patterns': [
          { 'include': '#wysiwyg-characters' }
        ]
      ]
    },
    'delimited-string-braces': {
      'patterns': [
        'begin': '\\{',
        'end': '\\}',
        'name': 'constant.character.delimited.braces.d',
        'patterns': [
          { 'include': '#wysiwyg-characters' }
        ]
      ]
    },

    'wysiwyg-characters': {
      'patterns': [
        { 'include': '#character' },
        { 'include': '#end-of-line' }
      ]
    },
    'double-quoted-characters': {
      'patterns': [
        { 'include': '#character' },
        { 'include': '#end-of-line' },
        { 'include': '#escape-sequence' }
      ]
    },
    'escape-sequence': {
      'patterns': [
        {
          # I really need to expand this
          'match': '(\\\\(?:quot|amp|lt|gt|tilde))',
          'name': 'constant.character.escape-sequence.entity.d'
        },
        {
          'match': '(\\\\x[0-9a-fA-F_]{2}|\\\\u[0-9a-fA-F_]{4}|\\\\U[0-9a-fA-F_]{8}|\\\\[0-7]{1,3})',
          'name': 'constant.character.escape-sequence.number.d',
        },
        {
          'match': '(\\\\t|\\\\\'|\\\\\"|\\\\\\?|\\\\0|\\\\a|\\\\b|\\\\f|\\\\n|\\\\r|\\\\v|\\\\\\\\)',
          'name': 'constant.character.escape-sequence.d',
        }
      ]
    },
    #
    # Character literal
    #
    'character-literal': {
      'patterns': [
        'match': "\'(?:(.)|(?:(?=\\\\)(.+)))\'"
        'name': 'string.character-literal.d',
        'captures': {
          '1' : {
            'patterns': [
              { 'include': '#character' }
            ]
          },
          '2': {
            'patterns': [
              { 'include': '#escape-sequence' }
            ]
          }
        }
      ]
    },
    'character': {
      'patterns': [
        'match': '[\\w\\s]',
        'name': 'string.character.d'
      ]
    },
    'end-of-line': {
      'patterns': [
        'match': '\\n',
        'name': 'string.character.end-of-line.d'
      ]
    },
    #
    # Identifiers
    #
    'identifier': {
      'patterns': [
        {
          'match': '[_\\w][_\\d\\w]*',
          'name': 'variable.d'
        }
      ]
    },
    #
    # Comments
    #
    'comment': {
      'patterns': [
        { 'include': '#block-comment' },
        { 'include': '#line-comment' },
        { 'include': '#nesting-block-comment' }
      ]
    },
    'block-comment': {
      'patterns': [
        {
          'begin': '/\\*',
          'end': '\\*/',
          'name': 'comment.block.d'
        }
      ]
    },
    'line-comment': {
      'patterns': [
        {
          'match': '//.+$',
          'name': 'comment.line.d'
        }
      ]
    },
    'nesting-block-comment': {
      'patterns': [
        {
          'begin': '/\\+',
          'end': '\\+/',
          'name': 'comment.block.documentation.d',
          'patterns': [
            { 'include': '$self' }
          ]
        }
      ]
    },
    #
    # Lexical Tokens, keywords and special tokens
    #
    'tokens': {
      'patterns': [
        { 'include': '#string-literal' },
        { 'include': '#character-literal' },
        { 'include': '#integer-literal' },
        { 'include': '#float-literal' },
        { 'include': '#keyword' },
        {
          'match': '/|/=|\\.|\\.\\.|\\.\\.\\.|&|&=|&&|\\||\\|=|\\|\\||-|-=|--|\\+|\\+=|\\+\\+|<|<=|<<|<>|>|>=|>>=|>>|>>>|\\!|\\!=|\\!<>|\\!<>=|\\!<|\\!<=|\\!>|\\!>=|\\(|\\)|\\[|\\]|\\{|\\}|\\?|,|;|:|$|=|==|\\*|\\*=|%|%=|\\^|\\^=|\\^\\^|\\^\\^=|~|~=|@|=>|#',
          'name': 'meta.lexical.token.symbolic.d'
        },
        { 'include': '#identifier' }
      ]
    },
    'keyword': {
      'patterns': [
        'match': 'abstract|alias|align|asm|assert|auto|body|bool|break|byte|case|cast|catch|cdouble|cent|cfloat|char|class|const|continue|creal|dchar|debug|default|delegate|delete|deprecated|do|double|else|enum|export|extern|false|final|finally|float|for|foreach|foreach_reverse|function|goto|idouble|if|ifloat|immutable|import|in|inout|int|interface|invariant|ireal|is|lazy|long|macro|mixin|module|new|nothrow|null|out|override|package|pragma|private|protected|public|pure|real|ref|return|scope|shared|short|static|struct|super|switch|synchronized|template|this|throw|true|try|typedef|typeid|typeof|ubyte|ucent|uint|ulong|union|unittest|ushort|version|void|volatile|wchar|while|with|__FILE__|__MODULE__|__LINE__|__FUNCTION__|__PRETTY_FUNCTION__|__gshared|__traits|__vector|__parameters',
        'name': 'keyword.token.d'
      ]
    }
  } # End of repository
} # End of d.cson
