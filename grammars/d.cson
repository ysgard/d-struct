# D Language grammar for Atom
#
# Props to http://www.regexr.com/ for helping me out with the regular
# expressions - really useful.
#
# Author: Jan Van Uytven

# For colors, as an example, Monokai defines the following.  It is probably
# likely that this are 'baseline' rules, as Monokai is one of the most
# popular styles
# .comment -> warm grey
# .string -> warm yellow
# .constant.numeric -> violet
# .constant.language -> violet
# .constant.character -> violet
# .constant.other -> violet
# .keyword -> coral
# .storage -> coral
# .storage.type -> blue italic
# .entity.name.class -> lime underline
# .entity.other.inherited-class -> lime italic underline
# .entity.name.function -> lime
# .entity.name.instance -> lt blue
# .variable.parameter -> orange italic
# .entity.name.tag -> coral
# .entity.other.attribute-name -> lime
# .support.function -> blue
# .support.type -> italic blue
# .support.class -> italic blue
# .invalid -> white on coral
# .invalid.deprecated -> white on purple
# .gfm.markup.heading -> bold lime
# .gfm.markup.underline -> warm yellow underline
# .gfm.markup.bold -> bold
# .gfm.markup.italic -> italic
# .gfm.markup.raw -> blue
# .gfm.markup.variable.list -> bold coral
# .gfm.markup.link -> lt grey
# .gfm.markup.link.entity -> violet

'fileTypes' : [
  'd'
  'di'
]
'name': 'D'
'scopeName': 'source.d'
# Root groups
# comment
#    line
#        double-slash
#    block
#        documentation
# constant
#    numeric
#    character
#    language
#    other
# entity - a block within the document
#    name
#        function
#        type
#        tag
#        section
#    other
#        inherited-class
#        attribute-name
# invalid
#    illegal
#    deprecated
# keyword
#    control
#    operator
#    other
# markup
#    underline
#        link
#    bold
#    heading
#    italic
#    list
#        numbered
#        unnumbered
#    quote
#    raw
#    other
# meta - larger blocks, like a whole function name.  Not styled
#    ???
# punctuation - not described in Textmate, presumably an Atom addition?
#    definition
#    separator
#    terminator
# storage
#    type
#    modifier
# string
#    quoted
#        single
#        double
#        triple
#        other
# support - items provided by the language/frameworkd, for example typeid() in D
#    function
#    class
#    type
#    constant
#    variable
#    other
# variable
#    parameter
#    language
#    other



'patterns' : [
    {
        'include': '#package'
    }
    {
        'include': '#code'
    }

]
# Repository of base constructs
# Use these to match code patterns
#
# all-types
# annotations
# anonymous-classes-and-new
# assertions
# attributes
# class
# class-body
# code
# comments
# comments-inline
# constants-and-special-vars
# enums
# functions
# keywords
# method-call
# methods
# object-types
# object-types-inherited
# parameters
# parens
# primitive-types
# storage-modifiers
# strings
# values
# variables

'repository':
    'all-types':
        'patterns': [

        ]
    'annotations':
        'patterns': [

        ]
    'attributes':
        'patterns': [
            {
                'match': '(@(safe|system|trusted|property))\\b'
                'name': 'keyword.other.safety.d'
            }
        ]
    'anonymous-classes-and-new':
        'patterns': [

        ]
    'assertions':
        # assert, enforce, exceptions and other contract structures
        'patterns': [
            {
                # Exception keywords
                'match': '\\b(try|catch|finally|throw|nothrow|in|body)\\b'
                'name': 'keyword.other.exception.d'
            }
            {
                # assertions
                'match': '\\b(assert|enforce|invariant)'
                'name': 'entity.name.function.assertion.d'
            }
        ]
    'block':
        # meta-pattern - any legal code that can exist inside { }
        'begin': '{'
        'end': '}'
        'patterns': [
            {
                'include': '#code'
            }
        ]
    'block-markup':
        'patterns': [
            {
                # single-line asm
                'match': '(asm)\\s+([^\\{\\}$]+)'
                'captures':
                    '1':
                        'name': 'keyword.other.asm.d'
                    '2':
                        'name': 'gfm.markup.raw.asm.d'
            }
            {
                # block-level asm
                'begin': '(asm)(?:\\s+{)'
                'beginCaptures':
                    '1':
                        'name': 'keyword.other.asm.d'
                'end': '}'
                'contentName': 'gfm.markup.raw.asm.d'
            }
        ]
    'class':
        'patterns': [

        ]
    'class-body':
        'patterns': [

        ]
    'code':
        # Meta class - basically all legal code that can be in a block
        'patterns': [
            {
                'include': '#functions'
            }
            {
                'include': '#assertions'
            }
            {
                'include': '#strings'
            }
            {
                'include': '#comments'
            }
            {
                'include': '#primitive-types'
            }
            {
                'include': '#constants-and-special-vars'
            }
            {
                'include': '#attributes'
            }
            {
                'include': '#keywords'
            }
            {
                'include': '#storage-modifiers'
            }
            {
                'include': '#block-markup'
            }
            {
                'include': '#variables'
            }
            {
                'include': '#methods'
            }

        ]
    'comments':
        'patterns': [
            {
                'captures':
                    '0':
                        'name': 'punctuation.definition.comment.d'
                'match': '/\\*\\*/'
                'name': 'comment.block.empty.d'
            }
            {
                'include': '#comments-inline'
            }
        ]
    'comments-inline':
        'patterns': [
            {
                # C-style comments
                'begin': '/\\*'
                'end': '\\*/'
                'name': 'comment.block.d'
            }
            {
                # C++-style comments
                'begin': '//'
                'end': '$'
                'name': 'comment.block.d'
            }
            {
                # Embedded documentation style
                'begin': '/\\+\\+'
                'end': '\\+/'
                'name': 'comment.block.embedded.d'
            }
        ]
    'constants-and-special-vars':
        'patterns': [
            {
                # Special constants
                'match': '\\b(true|false|null)\\b'
                'name': 'constant.language.d'
            }
            {
                # Special variables
                'match': '\\b(this|super)\\b'
                'name': 'variable.language.d'
            }
            {
                'include': '#numerics'
            }

        ]
    'enums':
        'patterns': [

        ]
    'functions':
        # Base functions
        'patterns': [
            {
                'match': '\\s+([a-zA-Z_][a-zA-Z0-9_]+)\\s*\\('
                'captures':
                    '1':
                        'name': 'entity.name.function.d'
            }
        ]
    'keywords':
        'patterns': [
            {
                # Control keywords
                'match': '\\b(case|continue|default|do|else|for|foreach|goto|if|return|switch|while)\\b'
                'name': 'keyword.control.d'
            }
            {
                # ternary keywords
                'match': '\\?|:'
                'name': 'keyword.control.ternary.d'
            }
            {
                # Type operators
                'match': '(\\b(typeid|typeof|is|!is)\\b)'
                'name': 'keyword.operator.d'
            }
            {
                # Bitwise operators & comparison
                'match': '(<<|>>>?|~|\\^|\\||&)'
                'name': 'keyword.operator.bitwise.d'
            }
            {
                # Bitwise assignment
                'match': '((&|\\^|\\||<<|>>>?)=)'
                'name': 'keyword.operator.assignment.bitwise.d'
            }
            {
                # Comparison operators
                'match': '(==|!=|<=|>=|<|>)'
                'name': 'keyword.operator.comparison.d'
            }
            {
                # Slice and array-specific operators
                'match': '(\\bin\\b)'
                'name': 'keyword.operator.array.d'
            }
            {
                # Arithmetic & concatenation
                'match': '(\\-|\\+|\\*|\\/|%|\\^\\^|~)'
                'name': 'keyword.operator.arithmetic.d'
            }
            {
                # Assignment
                'match': '([+*/%-~]?=)'
                'name': 'keyword.operator.assignment.d'
            }
            {
                # logical operators
                'match': '(!|&&|\\|\\|)'
                'name': 'keyword.operator.logical.d'
            }
            {
                # dereferencing, method refers, etc..
                'match': ''
                'name': 'keyword.operator.dereference.d'
            }
            {
                # statement terminator (semicolon)
                'match': ';'
                'name': 'punctuation.terminator.d'
            }
            {
                # alias
                'match': '(alias)\\s+(.+)\\s+(.+);'
                'captures':
                    '1':
                        'name': 'keyword.other.alias.d'
                    '2':
                        'name': 'variable.parameter.alias.d'
                    '3':
                        'name': 'variable.parameter.alias.d'
            }

        ]
    'method-call':
        'patterns': [

        ]
    'methods':
        'patterns': [
            {
                'match': '([a-zA-Z_][a-zA-Z0-9_]*)(\\.[a-zA-Z_][a-zA-Z0-9]+)+'
                'captures':
                    '1':
                        'name': 'entity.name.class.called.d'
                    '2':
                        'name': 'entity.name.function.method.d'
            }

        ]
    'numerics':
        # Match all numerics D is capable of (a lot!)
        'patterns': [
            {
                # Handle the weirdness that is hexadecimal floats
                'match': '0[xX][0-9a-fA-F_]*(\\.[0-9a-fA-F_]*)?([pP]|([pP][\+-]))[0-9][0-9_]*[LfF]?'
                'name': 'constant.numeric.float.hexidecimal.d'
            }
            {
                'match': '(((0[1-9_])|[1-9])?[0-9_]*\\.[0-9_]*([eE][\+-]?)?[0-9][0-9_]*[lfF]?)'
                'name': 'constant.numeric.float.d'
            }
            {
                # Hex, binary and octal integers
                'match': '0(((x|X)[0-9a-fA-F_]+)|([0-7_]+)|(b|B)[01_]+)([lL][uU]|[uU][lL]|[uUlL])?'
                'name': 'constant.numeric.integer.other.d'
            }
            {
                # base-10 integers
                'match': '[1-9][0-9_]*([lL][uU]|[uU][lL]|[uUlL])?'
                'name': 'constant.numeric.integer.decimal.d'
            }
        ]
    'object-types':
        'patterns': [


        ]
    'object-types-inherited':
        'patterns': [

        ]
    'package':
        # Module-level imports, module decls and package decls
        'patterns': [
            {
                # import packages
                'match': '\\b(import|module)\\s+(.+)\\b'
                'captures':
                    '1':
                        'name': 'keyword.other.import.d'
                    '2':
                        'name': 'support.class.import.d'
            }
        ]
    'parameters':
        # tag generic function and methos parameters
        'patterns': [
            # inout, in and out are parameter specific, handle them only here
            {
                'include': '#code'
                'name': 'variable.parameter.d'
            }

        ]
    'parens':
        # meta-pattern
        'patterns': [
            'begin': '\\('
            'end': '\\)'
            'patterns': [
                {
                    'include': '#code'
                }
            ]

        ]
    'primitive-types':
        'patterns': [
            {
            'match': '\\b((void|bool|byte|ubyte|short|ushort|int|uint|long|ulong|float|double|real|char|wchar|dchar|size_t|string|wstring|dstring|T|T1|T2|T3|V|R|E|S|U)(\\*{0,3})((\\[\\])*)(\\()?)\\s'
            'captures':
                '1':
                    'name': 'storage.type.primitive.array.d'
            }
        ]
    'storage-modifiers':
        'patterns': [
            {
                'match': '\\b(?:align|auto|const|export|extern|in|inout|out|pure|ref|static)\\b'
                'name': 'storage.modifier.data.d'
            }
        ]
    'strings':
        'patterns': [
            {
                'begin': '"'
                'beginCaptures':
                    '0':
                        'name': 'punctuation.definition.string.begin.d'
                'end': '"'
                'endCaptures':
                    '0':
                        'name': 'punctuation.definition.string.end.d'
                'name': 'string.quoted.double.d'
                # Deal with escape characters
                'patterns': [
                    {
                        'match': '\\\\.'
                        'name': 'constant.character.escape.d'
                    }
                ]
            }
        ]
    'values':
        'patterns': [

        ]
    'variables':
        'patterns': [
            {
                'match': '\\b([a-zA-Z_][A-Za-z0-9_]+)\\b'
                'name': 'support.variable.d'
            }
        ]
# Repository end
#
# End of d.cson
