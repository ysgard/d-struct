# D Language grammar for Atom
#
# Author: Jan Van Uytven

# For colors, as an example, Monokai defines the following.  It is probably
# likely that this are 'baseline' rules, as Monokai is one of the most
# popular styles
# .comment -> warm grey
# .string -> warm yellow
# .string source
# .string.unquoted
# .constant -> violet
# .constant.numeric -> violet
# .constant.language -> violet
# .constant.character -> violet
# .constant.other -> violet
# .declaration.section entity.name.section
# .declaration.tag
# .deco.folding
# .keyword -> coral
# .keyword.control
# .keyword.operator
# .storage -> coral
# .storage.type -> blue italic
# .entity.other.inherited-class -> lime italic underline
# .entity.name.function -> lime
# .entity.name.instance -> lt blue
# .entity.name.class -> lime underline
# .entity.name.tag -> coral
# .entity.name.type
# .entity.other.attribute-name -> lime
# .support.function -> blue
# .support.type -> italic blue
# .support.class -> italic blue
# .support.constant
# .support.variable
# .invalid -> white on coral
# .invalid.deprecated -> white on purple
# .variable.parameter -> orange italic
# .variable
# .variable.language
# .variable.other
# .meta.embedded
# .meta.preprocessor
# .meta.section entity.name.section
# .meta.tag
# .text source
# .gfm.markup.list
# .gfm.markup.quote
# .gfm.markup.heading -> bold lime
# .gfm.markup.underline -> warm yellow underline
# .gfm.markup.bold -> bold
# .gfm.markup.italic -> italic
# .gfm.markup.raw -> blue
# .gfm.markup.variable.list -> bold coral
# .gfm.markup.link -> lt grey
# .gfm.markup.link.entity -> violet

# The order of rules in 'patterns' is important - matching stops
# as soon as a match is found, starting from the top down.
{
  'fileTypes': [
    'd', 'di'
  ],
  'name': 'D',
  'scopeName': 'source.d',

  'patterns': [
    { 'include': '#comment' },
    { 'include': '#module-declaration' },
    { 'include': '#import-declaration' },
    { 'include': '#storage-class' },
    { 'include': '#condition' },
    { 'include': '#version-debug-specification' },
    { 'include': '#is-expression' },
    { 'include': '#attribute' },
    { 'include': '#asm-statement' },
    { 'include': '#mixin-expression' },
    { 'include': '#import-expression' },
    { 'include': '#assert-expression' },
    { 'include': '#typeid-expression' },
    { 'include': '#traits-expression' },
    { 'include': '#special-keyword' },
    { 'include': '#type' },
    { 'include': '#expression' },
  ],

  'repository': {
    #
    # GENERAL GRAMMAR
    #
    #
    # Basic Types
    #
    'type': {
      'patterns': [
        { 'include': '#type-ctor' },
        { 'include': '#basic-type' },
        { 'include': '#defined-type' },
        { 'include': '#basic-type-2' },
      ]
    },
    'type-ctor': {
      'patterns': [
        'match': '(const|immutable|inout|shared)+',
        'name': 'storage.type.modifier.d'
      ]
    },
    'basic-type': {
      'patterns': [
        { 'include': '#basic-type-x' },
        { 'include': '#typeof' },
        { 'include': '#type-ctor-type' },
      ]
    },
    'basic-type-x': {
      'patterns': [
        'match': 'bool|byte|ubyte|short|ushort|int|uint|long|ulong|char|wchar|dchar|float|double|real|ifloat|idouble|ireal|cfloat|cdouble|creal|void',
        'name': 'storage.type.basic-type-x.d'
      ]
    },
    'basic-type-2': {
      'patterns': [
        {
          'match': '\\*',
          'name': 'storage.type.pointer.d'
        },
        {
          'match': '\\[\\s*\\]',
          'name': 'storage.type.array.empty.d'
        },
        {
          'begin': '\\[',
          'beginCaptures': { '0': { 'name': 'storage.type.array.expression.begin.d' } },
          'end': '\\]',
          'endCaptures': { '0': { 'name': 'storage.type.array.expression.end.d' } },
          'patterns': [
            {
              'match': '\\.\\.|$',
              'name': 'keyword.operator.slice.d'
            },
            { 'include': '#type' },
            { 'include': '#expression' }
          ]
        },
        { 'include': '#delegate-basic-type-2' },
        { 'include': '#function-basic-type-2' }
      ]
    }
    'delegate-basic-type-2': {

    },
    'function-basic-type-2': {

    },
    # Defined in object.di
    'defined-type': {
      'patterns': [
        'match': 'wstring|dstring|string|size_t|ptrdiff_t',
        'name': 'storage.type.defined.d'
      ]
    }
    'typeof': {
      'begin': 'typeof\\s+\\(',
      'end': '\\)',
      'name': 'storage.type.typeof.d',
      'patterns': [
        {
            'match': 'return',
            'name': 'keyword.control.return.d'
        },
        { 'include': '#expression' }
      ],
    },
    'type-ctor-type': {
      'begin': '(const|immutable|inout|shared)\\s+\\(',
      'end': '\\)',
      'name': 'storage.type.ctor-type.d',
      'patterns': [
        { 'include': '#type' },
      ]
    },
    #
    #
    #
    #
    # Assert
    #
    'assert-expression': {
      'patterns': [
        'begin': 'assert\\s*\\(',
        'beginCaptures': { '0': { 'name': 'keyword.assert.begin.d' } },
        'end': '\\)',
        'endCaptures': { '0': { 'name': 'keyword.assert.end.d' } },
        'patterns': [
          { 'include': '#expression' }
        ]
      ]
    },
    #
    # Typeid
    #
    'typeid-expression': {
      'patterns': [
        'begin': 'typeid\\s*\\(',
        'beginCaptures': { '0': { 'name': 'keyword.typeid.begin.d' } },
        'end': '\\)',
        'endCaptures': { '0': { 'name': 'keyword.typeid.end.d' } },
        'patterns': [
          { 'include': '#type' },
          { 'include': '#expression' }
        ]
      ]
    },
    #
    # Imports
    #
    'import-expression': {
      'begin': 'import\\s*\\(',
      'beginCaptures': { '0': { 'name': 'keyword.import.begin.d' } },
      'end': '\\)',
      'endCaptures': { '0': { 'name': 'keyword.import.end.d' } },
      'patterns': [
        { 'include': '#expression' }
      ]
    },
    #
    # IsExpression and Type specializations
    # (MISSING TemplateTypeParameters)
    'is-expression': {
      'patterns': [
        {
          'begin': 'is\\s*\\(',
          'beginCaptures': { '0': { 'name': 'keyword.operator.is.begin.d' } },
          'end': '\\)',
          'endCaptures': { '0': { 'name': 'keyword.operator.is.end.d' } },
          'patterns': [
            {
              'match': ':|==|,',
              'name': 'keyword.operator.is-expression.d'
            },
            { 'include': '#type' },
            { 'include': '#type-specialization' },
            { 'include': '#identifier' },

          ]
        }
      ]
    },
    'type-specialization': {
      'patterns': [
        {
          'match': 'struct|union|class|interface|enum|function|delegate|super|const|immutable|inout|shared|return|__parameters',
          'name': 'keyword.other.type-specialization.d',
        },
        { 'include': '#type' },
      ]
    },

    #
    # Storage Classes
    #
    'storage-class': {
      'patterns': [
        {
          'match': 'deprecated|enum|static|extern|abstract|final|override|synchronized|auto|scope|const|immutable|inout|shared|__gshared|nothrow|pure|ref',
          'name': 'storage.class.d'
        },
        { 'include': '#linkage-attribute' },
        { 'include': '#align-attribute' },
        { 'include': '#property' },
      ]
    },
    #
    # Traits
    #
    'traits-expression': {
      'patterns': [
        'begin': '__traits\\s*\\(',
        'beginCaptures': { '0': { 'name': 'keyword.other.traits.begin.d' } },
        'end': '\\)',
        'endCaptures': { '0': { 'name': 'keyword.other.traits.end.d' } },
        'patterns': [
          { 'include': '#traits-keyword' },
          { 'include': '#traits-argument' }
        ]
      ]
    },
    'traits-keyword': {
      'patterns': [
        'match': 'isAbstractClass|isArithmetic|isAssociativeArray|isFinalClass|isPOD|isNested|isFloating|isIntegral|isScalar|isStaticArray|isUnsigned|isVirtualFunction|isVirtualMethod|isAbstractFunction|isFinalFunction|isStaticFunction|isOverrideFunction|isRef|isOut|isLazy|hasMember|identifier|getAliasThis|getAttributes|getMember|getOverloads|getProtection|getVirtualFunctions|getVirtualMethods|getUnitTests|parent|classInstanceSize|getVirtualIndex|allMembers|derivedMembers|isSame|compiles',
        'name': 'keyword.other.traits.d'
      ]
    },
    'traits-argument': {
      'patterns': [
        { 'include': '#expression' }
      ]
    },
    #
    # Special Keywords
    #
    'special-keyword': {
      'patterns': [
        'match': '__FILE__|__MODULE__|__LINE__|__FUNCTION__|__PRETTY_FUNCTION__',
        'name': 'keyword.other.special.d'
      ]
    }



    #
    # Expressions
    #
    # We cheat a bit here, since highlighting expressions is overkill, and in
    # any case we want lexical entities like strings and numbers to be
    # clearly visible.  So we group expressions into a meta class for the
    # purposes of other entities.  Expression entities themselves just highlight
    # lexical elements as well as the base expression operators, and a few
    # others.
    #
    'expression': {
      'patterns': [
          { 'include': '#operator' },
          {
            'match': ',',
            'name': 'keyword.operator.comma.d'
          }
          { 'include': '#lexical' },
      ]
    },
    'conditional-expression': {
      'patterns': [
        {
          # ternary
          'match': '\\?|:',
          'name': 'keyword.operator.ternary.d'
        },
        {
          # logical
          'match': '!<>=|!<=|!>=|<>=|!<>|<=|>=|<>|!>|!<|==|!=|&&|\\|\\||<|>',
          'name': 'keyword.operator.logical.d'
        },
        { 'include': '#lexical' }
      ]
    }
    'operator': {
      'patterns': [
        {
          # assign
          'match': '=|\\+=|-=|\\*=|/=|%=|&=|\\|=|\\^=|~=|<<=|>>=|>>>=|^^=',
          'name': 'keyword.operator.assign.d'
        },
        {
          # ternary
          'match': '\\?|:',
          'name': 'keyword.operator.ternary.d'
        },
        {
          # logical
          'match': '!<>=|!<=|!>=|<>=|!<>|<=|>=|<>|!>|!<|==|!=|&&|\\|\\||<|>',
          'name': 'keyword.operator.logical.d'
        },
        {
          # bitwise
          'match': '\\||\\^|&|<<|>>|>>>',
          'name': 'keyword.operator.bitwise.d'
        },
        {
          # arithmetic
          'match': '\\+|-|\\*|/|%',
          'name': 'keyword.operator.arithmetic.d'
        },
        {
          # unary
          'match': '[=~]\s*(&|\\+\\+|\\--|\\*|-|\\+|!)',
          'name': 'keyword.operator.unary.d'
        },
        {
          # misc
          'match': '~|(\\s+!in\\s+)|(\\s+in\\s+)',
          'name': 'keyword.operator.misc.d'
        },
        {
          # primary expressions
          'match': 'this|super|null|true|false|$',
          'name': 'constant.language.primary.d'
        }

      ]
    },
    'assign-operator': {
      'patterns': [
        {
          'match': '=|\\+=|-=|\\*=|/=|%=|&=|\\|=|\\^=|~=|<<=|>>=|>>>=|^^=',
          'name': 'keyword.operator.assign.d'
        },
        { 'include': '#expression' },
      ]
    },
    'ternary-operator': {
      'patterns:': [
        {
          'match': '(\\?|:)',
          'name': 'keyword.operator.ternary.d'
        },
        {
          'include': '#expression',
        }
      ]
    },
    #
    # Template
    #





    #
    # Declarations
    #
    'declaration': {
      'patterns': [
        { 'include': '#alias-declaration' },
        { 'include': '#aggregate-declaration' },
        { 'include': '#enum-declaration' },
        { 'include': '#import-declaration' },
        { 'include': '#decl' }
      ]
    },
    'alias-declaration': {
      'patterns': [
        {
          'match': 'alias',
          'name': 'keyword.alias.d'
        },
        { 'include': '#storage-class' },
        { 'include': '#basic-type' },
        { 'include': '#declarator' },
        { 'include': '#alias-declaration-x' }
      ]
    },
    #
    # Initializers
    #
    'initializer': {
      'patterns': [
        { 'include': '#void-initializer' },
        { 'include': '#non-void-initializer' }
      ]
    },
    'void-initializer': {
      'patterns': [
        'match': 'void',
        'name': 'support.type.void.d'
      ]
    },
    'non-void-initializer': {
      'patterns': [
        { 'include': '#exp-initializer' },
        { 'include': '#array-initializer' },
        { 'include': '#struct-initializer' }
      ]
    },
    'exp-initializer': {
      'patterns': [
        { 'include': '#expression' }
      ]
    },
    'array-initializer': {
      'patterns': [
        'begin': '\\[',
        'beginCaptures': { '0': { 'name': 'support.type.array.initializer.begin.d' } },
        'end': '\\]',
        'endCaptures': {'0': { 'name': 'support.type.array.initializer.end.d' } },
        'patterns': [
          {
            'match': ',',
            'name': 'keyword.operator.comma.d'
          },
          { 'include': '#array-member-initialization' },
        ]
      ]
    },
    'array-member-initializations': {
      'patterns': [
        {
          'match': ',',
          'name': 'keyword.operator.comma.d'
        },
        { 'include': '#array-member-initialization' },
      ]
    },
    'array-member-initialization': {
      'patterns': [
        { 'include': '#non-void-initializer' },
        { 'include': '#expression' },
        {
          'match': ':',
          'name': 'support.type.tag.d'
        }
      ]
    },
    'struct-initializer': {
      'patterns': [
        'begin': '\\{',
        'beginCaptures': { '0': { 'name': 'support.type.struct.initializer.begin.d' } },
        'end': '\\}',
        'endCaptures': { '0': { 'name': 'support.type.struct.initializer.end.d' } },
        'patterns': [
          { 'include': '#struct-member-initializers' }
        ]
      ]
    }
    'struct-member-initializers': {
      'patterns': [
        {
          'match': ',',
          'name': 'keyword.operator.comma.d'
        },
        { 'include': '#struct-member-initializer' },
      ]
    },
    'struct-member-initializer': {
      'patterns': [
        { 'include': '#non-void-initializer' },
        { 'include': '#identifier' },
        {
          'match': ':',
          'name': 'support.type.tag.d'
        },
      ]
    },

    #
    # Assembly (Iasm)
    #


    ###########################################################################
    # Type
    ###########################################################################



    ###########################################################################
    # Expression
    ###########################################################################

    ###########################################################################
    # Statement
    ###########################################################################




    ###########################################################################
    # Iasm
    ###########################################################################

    'asm-statement': {
      'patterns': [
        'begin': 'asm\\s*\\{',
        'end': '\\}',
        'beginCaptures': { '0': { 'name': 'keyword.control.asm.begin.d' } },
        'endCaptures': { '0': { 'name': 'keyword.control.asm.end.d' } },
        'patterns': [
          { 'include': '#asm-instruction' },
        ],
      ]
    },
    'asm-instruction': {
      'patterns': [
        {
          'match': 'align|even|naked|db|ds|di|dl|df|dd|de|:',
          'name': 'keyword.asm-instruction.d',
        },
        { 'include': '#operands' },
        { 'include': '#integer-expression' }
      ]
    },
    'operands': {
      'patterns': [
        {
          'match': ',',
          'name': 'keyword.operator.comma.assembly.d'
        }
        { 'include': '#asm-exp' },
      ]
    },
    'asm-exp': {
      'patterns': [
        {
          'match': '\\?|:',
          'name': 'keyword.operator.ternary.assembly.d',
        },
        {
          'match': '\\]|\\[',
          'name': 'keyword.operator.bracket.assembly.d',
        },
        {
          'match': '>>>|\\|\\||&&|==|!=|<=|>=|<<|>>|\\||\\^|&|<|>|\\+|-|\\*|/|%|~|!',
          'name': 'keyword.operator.assembly.d'
        },
        { 'include': '#asm-una-exp' },
      ]
    }
    'integer-expression': {
      'patterns': [
        { 'include': '#integer-literal' },
        { 'include': '#identifier' },
      ]
    },
    'asm-una-exp': {
      'patterns': [
        { 'include': '#asm-type-prefix' },
        {
          'match': 'offsetof|seg',
          'name': 'support.type.assembly.d'
        },
        { 'include': '#asm-primary-expression' },
      ]
    },
    'asm-primary-expression': {
      'patterns': [
        { 'include': '#integer-literal' },
        { 'include': '#float-literal' },
        {
          'match': '__LOCAL_SIZE',
          'name': 'constant.language.assembly.d'
        },
        { 'include': '#register' },
        { 'include': '#register-64' },
        { 'include': '#identifier' }
      ]
    },
    'asm-type-prefix': {
      'patterns': [
        'match': '(near\\s+ptr)|(far\\s+ptr)|(byte\\s+ptr)|(short\\s+ptr)|(int\\s+ptr)|(word\\s+ptr)|(dword\\s+ptr)|(qword\\s+ptr)|(float\\s+ptr)|(double\\s+ptr)|(real\\s+ptr)',
        'name': 'support.type.asm-type-prefix.d',
      ]
    },
    'register': {
      'patterns': [
        'match': 'XMM0|XMM1|XMM2|XMM3|XMM4|XMM5|XMM6|XMM7|MM0|MM1|MM2|MM3|MM4|MM5|MM6|MM7|ST\\(0\\)|ST\\(1\\)|ST\\(2\\)|ST\\(3\\)|ST\\(4\\)|ST\\(5\\)|ST\\(6\\)|ST\\(7\\)|ST|TR1|TR2|TR3|TR4|TR5|TR6|TR7|DR0|DR1|DR2|DR3|DR4|DR5|DR6|DR7|CR0|CR2|CR3|CR4|EAX|EBX|ECX|EDX|EBP|ESP|EDI|ESI|AL|AH|AX|BL|BH|BX|CL|CH|CX|DL|DH|DX|BP|SP|DI|SI|ES|CS|SS|DS|GS|FS',
        'name': 'storage.type.assembly.register.d',
      ]
    },
    'register-64': {
      'patterns': [
        'match': 'RAX|RBX|RCX|RDX|BPL|RBP|SPL|RSP|DIL|RDI|SIL|RSI|R8B|R8W|R8D|R8|R9B|R9W|R9D|R9|R10B|R10W|R10D|R10|R11B|R11W|R11D|R11|R12B|R12W|R12D|R12|R13B|R13W|R13D|R13|R14B|R14W|R14D|R14|R15B|R15W|R15D|R15|XMM8|XMM9|XMM10|XMM11|XMM12|XMM13|XMM14|XMM15|YMM0|YMM1|YMM2|YMM3|YMM4|YMM5|YMM6|YMM7|YMM8|YMM9|YMM10|YMM11|YMM12|YMM13|YMM14|YMM15',
        'name': 'storage.type.assembly.register-64.d'
      ]
    },
    ###########################################################################
    # Declaration
    ###########################################################################




    ###########################################################################
    # Function
    ###########################################################################
    'parameters': {
      'patterns': [
        {
          'match': '\\(\\s*\\.\\.\\.\\s*\\)',
          'name': 'support.type.tuple-parameter.d'
        },
        {
          'begin': '\\(',
          'beginCaptures': { '0': { 'name': 'support.type.parameters.begin.d' } },
          'end': '\\)',
          'endCaptures': { '0': { 'name': 'support.type.parameters.end.d' } },
          'patterns': [
              {
                'match': ',',
                'name': 'keyword.operator.comma.d'
              },
              { 'include': '#parameter' }
          ]
        }
      ]
    },
    'parameter': {
      'patterns': [
        { 'include': '#in-out' },
        { 'include': '#basic-type' },
        { 'include': '#type' },
        {
          'match': '\\.\\.\\.',
          'name': 'support.type.tuple.d'
        },
        { 'include': '#declarator' }
      ]
    },
    'in-out': {
      'patterns': [
        { 'include': '#in-out-x' }
      ]
    },
    'in-out-x': {
      'patterns': [
        {
          'match': 'auto|final|in|out|lazy|ref|scope',
          'name': 'storage.type.modifier.inout.d'
        },
        { 'include': '#type-ctor' }
      ]
    }
    'function-attributes': {
      'patterns': [
        { 'include': '#function-attribute' },
      ]
    },
    'function-attribute': {
      'patterns': [
        {
          'match': 'nothrow|pure',
          'name': 'storage.type.modifier.function-attribute.d'
        },
        {
          'include': '#property'
        }
      ]
    },
    'member-function-attributes': {
      'patterns': [
        { 'include': '#member-function-attribute' }
      ]
    },
    'member-function-attribute': {
      'patterns': [
        {
          'match': 'const|immutable|inout|shared',
          'name': 'storage.type.modifier.member-function-attribute'
        },
        { 'include': '#function-attribute' }
      ]
    },
    'default-initializer-expression': {
      'patterns': [
        { 'include': '#expression' },
        { 'include': '#special-keyword' }
      ]
    },
    'function-body': {
      'patterns': [
        { 'include': '#block-statement' },
        { 'include': '#in-statement' },
        { 'include': '#out-statement' },
        { 'include': '#body-statement' },
      ]
    },
    'in-statement': {
      'patterns': [
        {
          'match': 'in',
          'name': '#keyword.control.in.d'
        },
        { 'include': '#block-statement' }
      ]
    },
    'out-statement': {
      'patterns': [
        {
          'begin': 'out\\s*\\(',
          'beginCaptures': { '0': { 'name': 'keyword.control.out.begin.d' } },
          'end': '\\)',
          'endCaptures': { '0': { 'name': 'keyword.control.out.end.d' } },
          'patterns': [
            { 'include': '#identifier' }
          ]
        },
        {
          'match': 'out',
          'name': 'keyword.control.out.d'
        },
        { 'include': '#block-statement' }
      ]
    },
    'body-statement': {
      'patterns': [
        {
          'match': 'body',
          'name': 'keyword.control.body.d'
        },
        { 'include': '#block-statement' }
      ]
    },
    'constructor': {
      'patterns': [
        {
          'match': 'this',
          'name': 'entity.name.function.constructor.d'
        },
        { 'include': '#parameters' },
        { 'include': '#member-function-attributes' },
        { 'include': '#semi-colon' },
        { 'include': '#function-body' },
        { 'include': '#constructor-template' }
      ]
    },
    'constructor-template': {
      'patterns': [
        {
          'match': 'this',
          'name': 'entity.name.function.constructor-template.d'
        },
        { 'include': '#template-parameters' },
        { 'include': '#parameters' },
        { 'include': '#member-function-attributes'},
        { 'include': '#constraint' },
        { 'include': '#function-body' }
      ]
    },
    'destructor': {
      'patterns': [
        {
          'match': '~this\\s*\\(\\s*\\)',
          'name': '#entity.name.class.destructor.d'
        },
        { 'include': '#member-function-attributes' },
        { 'include': '#function-body' },
      ]
    },
    'postblit': {
      'patterns': [
        {
          'match': 'this\\s*\\(\\s*this\\s*\\)\\s',
          'name': '#entity.name.class.postblit.d'
        },
        { 'include': '#member-function-attributes' },
        { 'include': '#function-body'}
      ]
    },
    'allocator': {
      'patterns': [
        {
          'match': 'new',
          'name': 'keyword.other.new.d'
        },
        { 'include': '#parameters' },
        { 'include': '#function-body' }
      ]
    },
    'deallocator': {
      'patterns': [
        {
          'match': 'delete',
          'name': 'keyword.other.delete.d'
        },
        { 'include': '#parameters' },
        { 'include': '#function-body' }
      ]
    },
    'invariant': {
      'patterns': [
        {
          'match': 'invariant\\s*\\(\\s*\\)',
          'name': 'entity.name.class.invariant.d'
        },
        { 'include': '#block-statement' }
      ]
    },
    'unit-test': {
      'patterns': [
        {
          'match': 'unittest',
          'name': 'entity.name.function.unit-test.d'
        },
        { 'include': '#function-body' }
      ]
    },
    'static-constructor': {
      'patterns': [
        { 'include': '#shared-static-constructor' }
      ]
    },
    'static-destructor': {
      'patterns': [
        { 'include': '#shared-static-destructor' }
      ]
    },
    'shared-static-constructor': {
      'patterns': [
        {
          'match': '(shared\\s+)?static\\s+this\\s*\\(\\s*\\)',
          'name': 'entity.name.class.constructor.shared-static.d'
        },
        { 'include': '#function-body' }
      ]
    },
    'shared-static-destructor': {
      'patterns': [
        {
          'match': '(shared\\s+)?static\\s+~\\s*this\\s*\\(\\s*\\)',
          'name': 'entity.name.class.destructor.static.d'
        },
        { 'include': '#member-function-attributes' },
        { 'include': '#function-body' }
      ]
    },
    ###########################################################################
    # Aggregate
    ###########################################################################
    'aggregate-declaration': {
      'patterns': [
        { 'include': '#class-declaration' },
        { 'include': '#interface-declaration' },
        { 'include': '#struct-declaration' },
        { 'include': '#union-declaration' }
      ]
    },
    'class-declaration': {
      'patterns': [
        {
          'match': 'class',
          'name': 'entity.name.class.d'
        },
        { 'include': '#identifier' },
        { 'include': '#base-class-list' },
        { 'include': '#aggregate-body' },
        { 'include': '#class-template-declaration' }
      ]
    },
    'class-template-declaration': {
      'patterns': [
        {
          'match': 'class',
          'name': 'entity.name.class.d'
        },
        { 'include': '#identifier' },
        { 'include': '#template-parameters' },
        { 'include': '#constraint' },
        { 'include': '#base-class-list' },
        { 'include': '#aggregate-body' }
      ]
    },
    'interface-declaration': {
      'patterns': [
        {
          'match': 'interface',
          'name': 'entity.name.class.interface.d'
        },
        { 'include': '#identifier' },
        { 'include': '#base-interface-list' },
        { 'include': '#aggregate-body' },
        { 'include': '#interface-template-declaration' },
      ]
    },
    'interface-template-declaration': {
      'patterns': [
        {
          'match': 'interface',
          'name': 'entity.name.class.interface.d'
        },
        { 'include': '#identifier' },
        { 'include': '#template-parameters' },
        { 'include': '#constraint' },
        { 'include': '#base-class-list' },
        { 'include': '#aggregate-body' }
      ]
    },
    'struct-declaration': {
      'patterns': [
        {
          'match': 'struct',
          'name': 'storage.type.struct.d'
        },
        { 'include': '#identifier' },
        { 'include': '#aggregate-body' },
        { 'include': '#struct-template-declaration' },
        { 'include': '#anon-struct-declaration' }
      ]
    },
    'struct-template-declaration': {
      'patterns': [
        {
          'match': 'struct',
          'name': 'storage.type.struct.d'
        },
        { 'include': '#identifier' },
        { 'include': '#template-parameters' },
        { 'include': '#constraint' },
        { 'include': '#aggregate-body' },
      ]
    },
    'anon-struct-declaration': {
      'patterns': [
        {
          'match': 'struct',
          'name': 'storage.type.struct.d'
        },
        { 'include': '#aggregate-body' }
      ]
    },
    'union-declaration': {
      'patterns': [
        {
          'match': 'union',
          'name': 'storage.type.union.d'
        },
        { 'include': '#identifier' },
        { 'include': '#aggregate-body' },
        { 'include': '#union-template-declaration' },
        { 'include': '#anon-union-declaration' }
      ]
    },
    'union-template-declaration': {
      'patterns': [
        {
          'match': 'union',
          'name': 'storage.type.union.d'
        },
        { 'include': '#identifier' },
        { 'include': '#template-parameters' },
        { 'include': '#constraint' },
        { 'include': '#aggregate-body' }
      ]
    },
    'anon-union-declaration': {
      'patterns': [
        {
          'match': 'union',
          'name': 'storage.type.union.d'
        },
        { 'include': '#aggregate-body' }
      ]
    },
    'aggregate-body': {
      'patterns': [
        'begin': '\\{',
        'end': '\\}',
        'patterns': [
          { 'include': '#decl-defs' }
        ]
      ]
    },
    'base-class-list': {
      'patterns': [
        { 'include': '#colon' },
        { 'include': '#super-class' },
        { 'include': '#comma' },
        { 'include': '#interfaces' }
      ]
    },
    'base-interface-list': {
      'patterns': [
        { 'include': '#colon' },
        { 'include': '#interfaces' }
      ]
    },
    'super-class': {
      'patterns': [
        { 'include': '#identifier' },
      ]
    },
    'interfaces': {
      'patterns': [
        { 'include': '#comma' },
        { 'include': '#interface' }
      ]
    },
    'interface': {
      'patterns': [
        { 'include': '#identifier' }
      ]
    },
    'alias-this': {
      'begin': 'alias\\s+',
      'beginCaptures': { '0': { 'name': 'support.type.alias.d' } },
      'end': 'this',
      'endCaptures': { '0': { 'name': 'support.class.keyword.this.d' } },
      'patterns': [
        { 'include': '#identifier' }
      ]
    },
    ###########################################################################
    # Enum
    ###########################################################################
    'enum-declaration': {
      'patterns': [
        {
          'match': 'enum',
          'name': 'storage.type.enum.d'
        },
        { 'include': '#enum-tag' },
        { 'include': '#enum-body' },
        { 'include': '#colon' },
        { 'include': '#enum-base-type' }
      ]
    },
    'enum-tag': {
      'patterns': [
        { 'include': '#identifier' },
      ]
    },
    'enum-base-type': {
      'patterns': [
        { 'include': '#type' }
      ]
    },
    'enum-body': {
      'patterns': [
        { 'include': '#empty-enum-body' },
        { 'include': '#enum-members-body' }
      ]
    },
    'empty-enum-body': {
      'patterns': [
        { 'include': '#semi-colon' }
      ]
    },
    'enum-members-body': {
      'patterns': [
        'begin': '\\{',
        'end': '\\}',
        'patterns': [
          { 'include': '#enum-members' }
        ]
      ]
    },
    'enum-members': {
      'patterns': [
        { 'include': '#enum-member' },
        { 'include': '#comma' }
      ]
    },
    'enum-member': {
      'patterns': [
        { 'include': '#type' },
        { 'include': '#identifier' },
        { 'include': '#equal' },
        { 'include': '#expression '}
      ]
    },

    ###########################################################################
    # Template
    ###########################################################################
    'template-declaration': {
      'patterns': [
        {
          'match': 'template',
          'name': 'support.class.template.d',
        },
        { 'include': '#identifier' },
        { 'include': '#template-parameters' },
        { 'include': '#constraint' },
        {
          'begin': '\\{',
          'beginCaptures': { '0': { 'name': 'support.class.template.decldefs.begin.d' } },
          'end': '\\}',
          'endCaptures': { '0': { 'name': 'support.class.template.decldefs.end.d' } },
          'patterns': [
              { 'include': '#decl-defs' }
          ]
        }
      ]
    },
    'template-parameters': {
      'patterns': [
        'begin': '\\(',
        'beginCaptures': { '0': { 'name': 'support.class.template.parameters.begin.d' } },
        'end': '\\)',
        'endCaptures': { '0': { 'name': 'support.class.template.parameters.end.d' } },
        'patterns': [
          { 'include': '#template-parameter-list' }
        ]
      ]
    },
    'template-parameter-list': {
      'patterns': [
        {
          'match': ',',
          'name': 'keyword.operator.comma.d'
        },
        { 'include': '#template-parameter' }
      ]
    }
    'template-parameter': {
      'patterns': [
        { 'include': '#template-type-parameter' },
        { 'include': '#template-value-parameter' },
        { 'include': '#template-alias-parameter' },
        { 'include': '#template-tuple-parameter' },
        { 'include': '#template-this-parameter' },
      ]
    },
    'constraint': {
      'patterns': [
        'begin': 'if\\s+\\(',
        'beginCaptures': { '0': { 'name': 'support.class.template.constraint.begin.d' } },
        'end': '\\)',
        'endCaptures': { '0': { 'name': 'support.class.template.constraint.end.d' } },
        'patterns': [
          { 'include': '#expression' }
        ]
      ]
    },
    'template-instance': {
      'patterns': [
        { 'include': '#template-arguments' },
        { 'include': '#identifier' }
      ]
    },
    'template-arguments': {
      'patterns': [
        {
          'begin': '!\\s+\\(',
          'beginCaptures': { '0': { 'name': 'support.class.template.arguments.begin.d' } },
          'end': '\\)',
          'endCaptures': { '0': { 'name': 'support.class.template.arguments.end.d' } },
          'patterns': [
            { 'include': '#template-argument-list' }
          ]
        },
        {
          'match': '!',
          'name': 'support.class.template.argument.d'
        },
        { 'include': '#template-single-argument' }
      ]
    }
    'template-argument-list': {
      'patterns': [
        {
          'match': ',',
          'name': 'keyword.operator.comma.d'
        },
        { 'include': '#template-argument' }
      ]
    },
    'template-argument': {
      'patterns': [
        { 'include': '#type' },
        { 'include': '#expression' },
        { 'include': '#symbol' }
      ]
    },
    'symbol': {
      'patterns': [
        { 'include': '#symbol-tail' }
      ]
    },
    'symbol-tail': {
      'patterns': [
        { 'include': '#template-instance' },
        { 'include': '#identifier' },
      ]
    },
    'template-single-argument': {
      'patterns': [
        {
          'match': 'true|false|null|this',
          'name': 'constant.language.template-single-argument.d'
        },
        { 'include': '#special-keyword' },
        { 'include': '#basic-type-x' },
        { 'include': '#string-literal' },
        { 'include': '#character-literal' },
        { 'include': '#integer-literal' },
        { 'include': '#float-literal' },
        { 'include': '#identifier' }
      ]
    },
    'template-type-parameter': {
      'patterns': [
        { 'include': '#identifier' },
        { 'include': '#template-type-parameter-specialization' },
        { 'include': '#template-type-parameter-default' },
      ]
    },
    'template-type-parameter-specialization': {
      'patterns': [
        {
          'match': ':',
          'name': 'support.class.tag.d'
        },
        { 'include': '#type' }
      ]
    },
    'template-type-parameter-default': {
      'patterns': [
        {
          'match': '=',
          'name': 'support.class.template.operator.equal.d'
        },
        { 'include': '#type' }
      ]
    },
    'template-this-parameter': {
      'patterns': [
        {
          'match': 'this',
          'name': 'support.class.keyword.this.d'
        },
        { 'include': '#template-type-parameter' }
      ]
    },
    'template-value-parameter': {
      'patterns': [
        { 'include': '#basic-type' },
        { 'include': '#declarator' },
        { 'include': '#template-value-parameter-specialization' },
        { 'include': '#template-value-parameter-default' },
      ]
    },
    'template-value-parameter-specialization': {
      'patterns': [
        {
          'match': ':',
          'name': 'support.class.tag.d'
        },
        { 'include': '#conditional-expression' }
      ]
    },
    'template-value-parameter-default': {
      'patterns': [
        {
          'match': '=',
          'name': 'support.class.template.operator.equal.d'
        },
        { 'include': '#expression' },
        { 'include': '#special-keyword' }
      ]
    },
    'template-alias-parameter': {
      'patterns': [
        {
          'match': 'alias',
          'name': 'support.class.template.alias.d'
        },
        { 'include': '#identifier' },
        { 'include': '#template-alias-parameter-specialization' },
        { 'include': '#template-alias-parameter-default' },
        { 'include': '#basic-type' },
        { 'include': '#declarator' },
      ]
    },
    'template-alias-parameter-specialization': {
      'patterns': [
        {
          'match': ':',
          'name': 'support.class.tag.d'
        },
        { 'include': '#type' },
        { 'include': '#conditional-expression' }
      ]
    },
    'template-alias-parameter-default': {
      'patterns': [
        {
          'match': '=',
          'name': 'support.class.template.operator.equal.d'
        },
        { 'include': '#type' },
        { 'include': '#conditional-expression' }
      ]
    },
    'template-tuple-parameter': {
      'patterns': [
        { 'include': '#identifier' },
        {
          'match': '\\.\\.\\.',
          'name': 'support.type.tuple.d'
        }
      ]
    },
    'template-mixin-declaration': {
      'patterns': [
        'begin': 'mixin\\s+template\\s+',
        'beginCaptures': { '0': { 'name': 'support.class.template.mixin.template.begin.d' } },
        'end': '\\{(.*)\\}',
        'endCaptures': {
          '0': {
            'name': 'support.class.template.mixin.template.end.d',
            'patterns': [
              { 'include': '#decl-defs' }
            ]
          },
        },
        'patterns': [
          { 'include': '#identifier' },
          { 'include': '#template-parameters' },
          { 'include': '#constraint' }
        ]
      ]
    },
    'template-mixin': {
      'patterns': [
        'begin': 'mixin\\s+',
        'beginCaptures': { '0': { 'name': 'support.class.template.mixin.begin.d' } },
        'end': ';',
        'endCaptures': { '0': { 'name': 'support.class.template.mixin.end.d' } },
        'patterns': [
          { 'include': '#mixin-template-name' },
          { 'include': '#template-arguments' },
          { 'include': '#identifier' }
        ]
      ]
    },
    'mixin-template-name': {
      'patterns': [
        { 'include': '#qualified-identifier-list' },
        { 'include': '#typeof' },
      ]
    },
    'qualified-identifier-list': {
      'patterns': [
        { 'include': '#identifier' },
        { 'include': '#template-instance' },
      ]
    },




    ###########################################################################
    # Attribute
    ###########################################################################
    'attribute-specifier': {
      'patterns': [
        { 'include': '#attribute' },
        { 'include': '#colon' },
        { 'include': '#declaration-block' }
      ]
    },
    'attribute': {
      'patterns': [
        { 'include': '#linkage-attribute' },
        { 'include': '#align-attribute' },
        { 'include': '#deprecated-attribute' },
        { 'include': '#protection-attribute' },
        { 'include': '#pragma' },
        {
          'match': 'static|extern|abstract|final|override|synchronized|auto|scope|const|immutable|inout|shared|__gshared|nothrow|pure|ref',
          'name': 'entity.other.attribute-name.d'
        },
        { 'include': '#property' },
      ]
    },
    'declaration-block': {
      'patterns': [
        {
          'begin': '\\{',
          'end': '\\}',
          'patterns': [
            { 'include': '#decl-defs' },
          ]
        }
        { 'include': '#decl-def' },
      ]
    }
    'linkage-attribute': {
      'patterns': [
        {
          'begin': 'extern\\s*\\(\\s*C\\+\\+,',
          'beginCaptures': { '0': { 'name': 'keyword.other.extern.cplusplus.begin.d' } },
          'end': '\\)',
          'endCaptures': { '0': { 'name': 'keyword.other.extern.cplusplus.end.d' } },
          'patterns': [
            { 'include': '#identifier-list' },
          ]
        },
        {
          'begin': 'extern\\s*\\(',
          'beginCaptures': { '0': { 'name': 'keyword.other.extern.begin.d' } },
          'end': '\\)',
          'endCaptures': { '0': { 'name': 'keyword.other.extern.end.d' } },
          'patterns': [
            { 'include': '#linkage-type' },
          ]
        }
      ]
    },
    'linkage-type': {
      'patterns': [
        'match': 'C|C\\+\\+|D|Windows|Pascal|System',
        'name': 'storage.modifier.linkage-type.d'
      ]
    },
    'align-attribute': {
      'patterns': [
        {
          'begin': 'align\\(',
          'end': '\\)',
          'name': 'storage.modifier.align-attribute.d',
          'patterns': [
            { 'include': '#integer-literal' }
          ]
        },
        {
          'match': 'align\\s*[^\\(]',
          'name': 'storage.modifier.align-attribute.d',
        }
      ]
    },
    'deprecated-attribute': {
      'patterns': [
        {
          'begin': 'deprecated\\s*\\(',
          'beginCaptures': { '0': { 'name': 'keyword.other.deprecated.begin.d' } },
          'end': '\\)',
          'endCaptures': { '0': { 'name': 'keyword.other.deprecated.end.d' } },
          'patterns': [
            { 'include': '#string-literal' },
          ]
        },
        {
          'match': 'deprecated\\s*[^\\(]',
          'name': 'keyword.other.deprecated.plain.d'
        }
      ]
    },
    'protection-attribute': {
      'patterns': [
        'match': 'private|package|protected|public|export',
        'name': 'keyword.other.protections.d'
      ]
    },
    'property': {
      'patterns': [
        {
          'match': '@(property|safe|trusted|system|disable|nogc)',
          'name': 'entity.name.tag.property.d',
        },
      ]
    },
    'property-identifier': {
      'patterns': [
        'match': 'property|safe|trusted|system|disable|nogc',
        'name': 'entity.name.tag.property.d'
      ]
    },
    'user-defined-attribute': {
      'patterns': [
        {
          'match': '@([_\\w][_\\d\\w]*)',
          'name': 'entity.name.tag.user-defined-property.d',
        },
        {
          'begin': '@([_\\w][_\\d\\w]*)\\(',
          'end': '\\)',
          'name': 'entity.name.tag.user-defined-property.d',
          'patterns': [
            { 'include': '#expression' }
          ]
        }
      ]
    },

    'pragma': {
      'patterns': [
        {
          'match': 'pragma\\s?\\(\\s*[_\\w][_\\d\\w]*\\s*\\)',
          'name': 'gfm.markup.header.preprocessor.pragma.d'
        },
        {
          'begin': 'pragma\\s?\\(\\s*[_\\w][_\\d\\w]*\\s*,',
          'end': '\\)',
          'name': 'gfm.markup.header.preprocessor.pragma.arguments.d'
          'patterns': [
            { 'include': '#expression' },
          ]
        },
        {
          'match': '^#!.+',
          'name': 'gfm.markup.header.preprocessor.script-tag.d'
        }
      ]
    },
    ###########################################################################
    # Conditional
    ###########################################################################
    'conditional-declaration': {
      'patterns': [
        { 'include': '#condition' },
        { 'include': '#declaration-block' },
        {
          'match': 'else',
          'name': 'keyword.control.else.d'
        },
        { 'include': '#colon' },
        { 'include': '#decl-defs' },
      ]
    },
    'conditional-statement': {
      'patterns': [
        { 'include': '#condition' },
        { 'include': '#no-scope-non-empty-statement' },
        {
          'match': 'else',
          'name': 'keyword.control.else.d'
        },
      ]
    },
    'condition': {
      'patterns': [
        { 'include': '#version-condition' },
        { 'include': '#debug-condition' },
        { 'include': '#static-if-condition' },
      ]
    },
    'version-condition': {
      'patterns': [
        {
          'match': 'version\\s*\\(\\s*unittest\\s*\\)',
          'name': 'keyword.other.version.unittest.d'
        },
        {
          'match': 'version\\s*\\(\\s*assert\\s*\\)',
          'name': 'keyword.other.version.assert.d'
        },
        {
          'begin': 'version\\s*\\(',
          'beginCaptures': {
            '0': { 'name': 'keyword.other.version.identifier.begin.d' },
          },
          'end': '\\)',
          'endCaptures': {
            '0': { 'name': 'keyword.other.version.identifer.end.d' }
          }
          'patterns': [
            { 'include': '#integer-literal' },
            { 'include': '#identifier' }
          ]
        }
      ]
    },
    'debug-condition': {
      'patterns': [
        {
          'begin': 'debug\\s*\\(',
          'beginCaptures': { '0': { 'name': 'keyword.other.debug.identifier.begin.d' } },
          'end': '\\)',
          'endCaptures': { '0': { 'name': 'keyword.other.debug.identifier.end.d' } },
          'patterns': [
            { 'include': '#integer-literal' },
            { 'include': '#identifier' },
          ],
        },
        {
          'match': 'debug\\s*[^\\(\\s)]',
          'name': 'keyword.other.debug.plain.d'
        }
      ]
    },
    'version-specification': {
      'patterns': [
        'match': 'version\\s*=',
        'name': 'keyword.other.version-specification.d'
      ]
    },
    'debug-specification': {
      'patterns': [
        'match': 'debug\\s*=',
        'name': 'keyword.other.debug-specification.d'
      ]
    },
    'static-if-condition': {
      'patterns': [
        'begin': 'static\\s*if\\s*\\(',
        'beginCaptures': { '0': { 'name': 'keyword.other.static-if.begin.d' } },
        'end': '\\)',
        'endCaptures': { '0': { 'name': 'keyword.other.static-if.end.d' } },
        'patterns': [
          { 'include' : '#expression' }
        ],
      ]
    }
    'static-assert': {
      'patterns': [
        'begin': 'static\\s*assert\\s*\\(',
        'beginCaptures': { '0': { 'name': 'keyword.other.static-assert.begin.d' } },
        'end': '\\)',
        'endCaptures': { '0': { 'name': 'keyword.other.static-assert.end.d' } },
        'patterns': [
          { 'include' : '#expression' }
        ],
      ]
    },
    ###########################################################################
    # Module
    ###########################################################################
    'module': {
      'packages': [
        { 'import': '#module-declaration' },
        { 'import': '#decl-defs' }
      ]
    },
    'decl-defs': {
      'packages': [
        { 'include': '#decl-def' }
      ]
    },
    'decl-def': {
      'packages': [
        { 'include': '#attribute-specifier' },
        { 'include': '#declaration' },
        { 'include': '#constructor' },
        { 'include': '#destructor' },
        { 'include': '#postblit' },
        { 'include': '#allocator' },
        { 'include': '#deallocator' },
        { 'include': '#invariant' },
        { 'include': '#unit-test' },
        { 'include': '#alias-this' },
        { 'include': '#static-constructor' },
        { 'include': '#static-destructor' },
        { 'include': '#conditional-declaration' },
        { 'include': '#debug-specification' },
        { 'include': '#version-specification' },
        { 'include': '#static-assert' },
        { 'include': '#template-declaration' },
        { 'include': '#template-mixin-declaration' },
        { 'include': '#template-mixin' },
        { 'include': '#mixin-declaration' },
        { 'include': '#shared-static-constructor' },
        { 'include': '#shared-static-destructor' },
        { 'include': '#semi-colon' },
      ]
    },
    'module-declaration': {
      'patterns': [
        'begin': 'module\\s+',
        'beginCaptures': { '0': { 'name': 'keyword.package.module.d' } },
        'end': ';',
        'patterns': [
          { 'include': '#module-fully-qualified-name' }
        ]
      ]
    },
    'module-fully-qualified-name': {
      'patterns': [
        { 'include': '#module-name' },
      ]
    },
    'module-name': {
      'patterns': [
        { 'include': '#identifier' }
      ]
    },
    'packages': {
      'patterns': [
        { 'include': '#package-name' }
      ]
    },
    'package-name': {
      'patterns': [
        { 'include': '#identifier' }
      ]
    },

    ###########################################################################
    # Import Declarations
    ###########################################################################
    'import-declaration': {
      'patterns': [
        {
          'match': '(static\\s+)?import\\s+',
          'name': 'keyword.package.import.d'
        },
        {
          '#include': '#import-list'
        }
      ]
    },
    'import-list': {
      'patterns': [
        { 'include': '#import' },
        { 'include': '#import-bindings' },
        { 'include': '#comma' },
      ]
    },
    'import': {
      'patterns': [
        { 'include': '#module-fully-qualified-name' },
        { 'include': '#module-alias-identifier' },
        { 'include': '#equal' }
      ]
    },
    'import-bindings': {
      'patterns': [
        { 'include': '#import' },
        { 'include': '#colon' },
        { 'include': '#import-bind-list' }
      ]
    },
    'import-bind-list': {
      'patterns': [
        { 'include': '#comma' },
        { 'include': '#import' }
      ]
    },
    'import-bind': {
      'patterns': [
        { 'include': '#identifier' },
        { 'include': '#equal' }
      ]
    },
    'module-alias-identifier': {
      'patterns': [
        { 'include': '#identifier' }
      ]
    }
    ###########################################################################
    # Mixin Decl
    ###########################################################################
    'mixin-declaration': {
      'patterns': [
        'begin': 'mixin\\s*\\(',
        'end': '\\)',
        'beginCaptures': { '0': { 'name': 'keyword.mixin.begin.d' } },
        'endCaptures': { '0': { 'name': 'keyword.mixin.end.d' } },
        'patterns': [
          { 'include': '#expression' }
        ]
      ]
    },
    ###########################################################################
    # Misc
    ###########################################################################
    'comma': {
      'patterns': [
        'match': ',',
        'name': 'keyword.operator.comma.d'
      ]
    },
    'colon': {
      'patterns': [
        'match': ':',
        'name': 'support.type.colon.d'
      ]
    },
    'equal': {
      'patterns': [
        'match': '=',
        'name': 'keyword.operator.equal.d'
      ]
    },
    'semi-colon': {
      'patterns': [
        'match': ';',
        'name': 'meta.statement.semi-colon.d'
      ]
    },

    ###########################################################################
    #
    # LEXICAL TOKENS
    #
    ###########################################################################
    'lexical': {
      'patterns': [
        { 'include': '#string-literal' },
        { 'include': '#character-literal' },
        { 'include': '#float-literal' },
        { 'include': '#integer-literal' },
        { 'include': '#special-tokens' },
        { 'include': '#special-token-sequence' },
        { 'include': '#identifier' },
      ]
    },
    #
    # Integer literals
    #
    'integer-literal': {
      'patterns': [
        { 'include': '#decimal-integer' },
        { 'include': '#binary-integer' },
        { 'include': '#hexadecimal-integer' }
      ]
    },
    'decimal-integer': {
      # We avoid including sub-rules at this point, as we can handle this
      # with a single regex
      'patterns': [
        'match': '(0(?=[^\\dxXbB]))|([1-9][0-9_]*)(Lu|LU|uL|UL|L|u|U)?',
        'name': 'constant.numeric.integer.decimal.d'
      ]
    },
    'binary-integer': {
      'patterns': [
        'match': '(0b|0B)[0-1_]+(Lu|LU|uL|UL|L|u|U)?',
        'name': 'constant.numeric.integer.binary.d'
      ]
    },
    'hexadecimal-integer': {
      'patterns': [
        'match': '(0x|0X)([0-9a-fA-F][0-9a-fA-F_]*)(Lu|LU|uL|UL|L|u|U)?',
        'name': 'constant.numeric.integer.hexadecimal.d'
      ]
    },
    #
    # Float literals
    #
    'float-literal': {
      'patterns': [
        { 'include': '#decimal-float' },
        { 'include': '#hexadecimal-float' }
      ]
    },
    'decimal-float': {
      'patterns': [
        'match': '((\\.[0-9])|(0\\.)|(([1-9]|(0[1-9_]))[0-9_]*\\.))[0-9_]*((e-|E-|e\\+|E\\+|e|E)[0-9][0-9_]*)?[LfF]?i?',
        'name': 'constant.numeric.float.decimal.d'
      ]
    },
    'hexadecimal-float': {
      # Is there a reason why anyone would use a hexadecimal floating point?  Mystery...
      'patterns': [
        'match': '0[xX][0-9a-fA-F_]*(\\.[0-9a-fA-F_]*)?(p-|P-|p\\+|P\\+|p|P)[0-9][0-9_]*[LfF]?i?',
        'name': 'constant.numeric.fload.hexadecimal.d'
      ]
    },

    #
    # String literals
    #
    'string-literal': {
      'patterns': [
        { 'include': '#wysiwyg-string' },
        { 'include': '#alternate-wysiwyg-string' },
        { 'include': '#hex-string' },
        { 'include': '#delimited-string' },
        { 'include': '#double-quoted-string' },
        { 'include': '#token-string' }
      ]
    },
    'wysiwyg-string': {
      'patterns': [
        'begin': 'r\\"',
        'end': '\\"[cwd]?',
        'name': 'string.wysiwyg-string.d',
        'patterns': [
          { 'include': '#wysiwyg-chars' }
        ]
      ]
    },
    'alternate-wysiwyg-string': {
      'patterns': [
        'begin': '`',
        'end': '`[cwd]?',
        'name': 'string.alternate-wysiwyg-string.d',
        'patterns': [
          { 'include': '#wysiwyg-characters' }
        ]
      ]
    },
    'double-quoted-string': {
      'patterns': [
        'begin': '"',
        'end': '"[cwd]?',
        'name': 'string.double-quoted-string.d',
        'patterns': [
          { 'include': '#double-quoted-characters' }
        ]
      ]
    },
    'hex-string': {
      'patterns': [
        'begin': 'x"',
        'end': '"[cwd]?',
        'name': 'string.hex-string.d',
        'patterns': [
          {
            'match': '[a-fA-F0-9_\s]+',
            'name': 'constant.character.hex-string.d'
          }
        ]
      ]
    },
    'delimited-string': {
      'begin': 'q"',
      'end': '"',
      'name': 'string.delimited.d',
      'patterns': [
        { 'include': '#delimited-string-bracket' },
        { 'include': '#delimited-string-parens' },
        { 'include': '#delimited-string-angle-brackets' },
        { 'include': '#delimited-string-braces' },
        { 'include': '#delimited-string-arbitrary' },
      ]
    },
    'token-string': {
      'begin': 'q\\{',
      'end': '\\}',
      'name': 'string.token.d',
      'patterns': [
        { 'include': '#tokens' }
      ]
    },
    'delimited-string-arbitrary': {
      # Tricky one, as we can't match the arbitrary delimiter between a 'begin'
      # or 'end', so we have to hack this one:
      'patterns': [
        'match': '(.)([\\w\\s\\n]*?)(\\1)'
        'captures': {
          '1': {
            'name': 'constant.character.delimiter.d'
          },
          '2': {
            'name': 'string.delimited.d'
          },
          '3': {
            'name': 'constant.character.delimiter.d'
          },
        }
      ]
    },
    'delimited-string-bracket': {
      'patterns': [
        'begin': '\\[',
        'end': '\\]',
        'name': 'constant.characters.delimited.brackets.d',
        'patterns': [
          { 'include': '#wysiwyg-characters' }
        ]
      ]
    },
    'delimited-string-parens': {
      'patterns': [
        'begin': '\\(',
        'end': '\\)',
        'name': 'constant.character.delimited.parens.d',
        'patterns': [
          { 'include': '#wysiwyg-characters' }
        ]
      ]
    },
    'delimited-string-angle-brackets': {
      'patterns': [
        'begin': '<',
        'end': '>',
        'name': 'constant.character.angle-brackets.d',
        'patterns': [
          { 'include': '#wysiwyg-characters' }
        ]
      ]
    },
    'delimited-string-braces': {
      'patterns': [
        'begin': '\\{',
        'end': '\\}',
        'name': 'constant.character.delimited.braces.d',
        'patterns': [
          { 'include': '#wysiwyg-characters' }
        ]
      ]
    },

    'wysiwyg-characters': {
      'patterns': [
        { 'include': '#character' },
        { 'include': '#end-of-line' }
      ]
    },
    'double-quoted-characters': {
      'patterns': [
        { 'include': '#character' },
        { 'include': '#end-of-line' },
        { 'include': '#escape-sequence' }
      ]
    },
    'escape-sequence': {
      'patterns': [
        {
          # named entities
          'match': '(\\\\(?:quot|amp|lt|gt|OElig|oelig|Scaron|scaron|Yuml|circ|tilde|ensp|emsp|thinsp|zwnj|zwj|lrm|rlm|ndash|mdash|lsquo|rsquo|sbquo|ldquo|rdquo|bdquo|dagger|Dagger|permil|lsaquo|rsaquo|euro|nbsp|iexcl|cent|pound|curren|yen|brvbar|sect|uml|copy|ordf|laquo|not|shy|reg|macr|deg|plusmn|sup2|sup3|acute|micro|para|middot|cedil|sup1|ordm|raquo|frac14|frac12|frac34|iquest|Agrave|Aacute|Acirc|Atilde|Auml|Aring|Aelig|Ccedil|egrave|eacute|ecirc|iuml|eth|ntilde|ograve|oacute|ocirc|otilde|ouml|divide|oslash|ugrave|uacute|ucirc|uuml|yacute|thorn|yuml|fnof|Alpha|Beta|Gamma|Delta|Epsilon|Zeta|Eta|Theta|Iota|Kappa|Lambda|Mu|Nu|Xi|Omicron|Pi|Rho|Sigma|Tau|Upsilon|Phi|Chi|Psi|Omega|alpha|beta|gamma|delta|epsilon|zeta|eta|theta|iota|kappa|lambda|mu|nu|xi|omicron|pi|rho|sigmaf|sigma|tau|upsilon|phi|chi|psi|omega|thetasym|upsih|piv|bull|hellip|prime|Prime|oline|frasl|weierp|image|real|trade|alefsym|larr|uarr|rarr|darr|harr|crarr|lArr|uArr|rArr|dArr|hArr|forall|part|exist|empty|nabla|isin|notin|ni|prod|sum|minux|lowast|radic|prop|infin|ang|and|or|cap|cup|int|there4|sim|cong|asymp|ne|equiv|le|ge|sub|sup|nsub|sube|supe|oplus|otimes|perp|sdot|lceil|rceil|lfloor|rfloor|loz|spades|clubs|hearts|diams|lang|rang))',
          'name': 'constant.character.escape-sequence.entity.d'
        },
        {
          'match': '(\\\\x[0-9a-fA-F_]{2}|\\\\u[0-9a-fA-F_]{4}|\\\\U[0-9a-fA-F_]{8}|\\\\[0-7]{1,3})',
          'name': 'constant.character.escape-sequence.number.d',
        },
        {
          'match': '(\\\\t|\\\\\'|\\\\\"|\\\\\\?|\\\\0|\\\\a|\\\\b|\\\\f|\\\\n|\\\\r|\\\\v|\\\\\\\\)',
          'name': 'constant.character.escape-sequence.d',
        }
      ]
    },
    #
    # Character literal
    #
    'character-literal': {
      'patterns': [
        'match': "\'(?:(.)|(?:(?=\\\\)(.+)))\'"
        'name': 'string.character-literal.d',
        'captures': {
          '1' : {
            'patterns': [
              { 'include': '#character' }
            ]
          },
          '2': {
            'patterns': [
              { 'include': '#escape-sequence' }
            ]
          }
        }
      ]
    },
    'character': {
      'patterns': [
        'match': '[\\w\\s]',
        'name': 'string.character.d'
      ]
    },
    'end-of-line': {
      'patterns': [
        'match': '\\n',
        'name': 'string.character.end-of-line.d'
      ]
    },
    #
    # Identifiers
    #
    'identifier-list': {
      'patterns': [
        {
          'match': ',',
          'name': 'keyword.other.comma.d'
        },
        { 'include': '#identifier' }
      ]
    },
    'identifier': {
      'patterns': [
        {
          'match': '(\\.?[_\\w][_\\d\\w]*)+',
          'name': 'invalid.d'
        },
      ]
    },
    #
    # Comments
    #
    'comment': {
      'patterns': [
        { 'include': '#block-comment' },
        { 'include': '#line-comment' },
        { 'include': '#nesting-block-comment' }
      ]
    },
    'block-comment': {
      'patterns': [
        {
          'begin': '/\\*',
          'end': '\\*/',
          'name': 'comment.block.d'
        }
      ]
    },
    'line-comment': {
      'patterns': [
        {
          'match': '//.+$',
          'name': 'comment.line.d'
        }
      ]
    },
    'nesting-block-comment': {
      'patterns': [
        {
          'begin': '/\\+',
          'end': '\\+/',
          'name': 'comment.block.documentation.d',
          'patterns': [
            { 'include': '$self' }
          ]
        }
      ]
    },
    #
    # Lexical Tokens, keywords and special tokens
    #
    'tokens': {
      'patterns': [
        { 'include': '#string-literal' },
        { 'include': '#character-literal' },
        { 'include': '#integer-literal' },
        { 'include': '#float-literal' },
        { 'include': '#keyword' },
        {
          'match': '/|/=|\\.|\\.\\.|\\.\\.\\.|&|&=|&&|\\||\\|=|\\|\\||-|-=|--|\\+|\\+=|\\+\\+|<|<=|<<|<>|>|>=|>>=|>>|>>>|\\!|\\!=|\\!<>|\\!<>=|\\!<|\\!<=|\\!>|\\!>=|\\(|\\)|\\[|\\]|\\{|\\}|\\?|,|;|:|$|=|==|\\*|\\*=|%|%=|\\^|\\^=|\\^\\^|\\^\\^=|~|~=|@|=>|#',
          'name': 'meta.lexical.token.symbolic.d'
        },
        { 'include': '#identifier' }
      ]
    },
    'keyword': {
      'patterns': [
        'match': 'abstract|alias|align|asm|assert|auto|body|bool|break|byte|case|cast|catch|cdouble|cent|cfloat|char|class|const|continue|creal|dchar|debug|default|delegate|delete|deprecated|do|double|else|enum|export|extern|false|final|finally|float|for|foreach|foreach_reverse|function|goto|idouble|if|ifloat|immutable|import|in|inout|int|interface|invariant|ireal|is|lazy|long|macro|mixin|module|new|nothrow|null|out|override|package|pragma|private|protected|public|pure|real|ref|return|scope|shared|short|static|struct|super|switch|synchronized|template|this|throw|true|try|typedef|typeid|typeof|ubyte|ucent|uint|ulong|union|unittest|ushort|version|void|volatile|wchar|while|with|__FILE__|__MODULE__|__LINE__|__FUNCTION__|__PRETTY_FUNCTION__|__gshared|__traits|__vector|__parameters',
        'name': 'keyword.token.d'
      ]
    },
    'special-token-sequence': {
      'patterns': [
        'match': '#\\s*line\\s+.+',
        'name': 'gfm.markup.italic.special-token-sequence.d'
      ]
    },
    'special-tokens': {
      'patterns': [
        'match': '__DATE__|__EOF__|__TIME__|__TIMESTAMP__|__VENDOR__|__VERSION__',
        'name': 'gfm.markup.raw.special-tokens.d'
      ]
    }
  } # End of repository
} # End of d.cson
